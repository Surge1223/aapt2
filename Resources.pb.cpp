// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/tools/aapt2/Resources.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "frameworks/base/tools/aapt2/Resources.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace aapt {
namespace pb {

void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto() {
  delete ConfigDescription::default_instance_;
  delete StringPool::default_instance_;
  delete SourcePosition::default_instance_;
  delete Source::default_instance_;
  delete ResourceTable::default_instance_;
  delete Package::default_instance_;
  delete Type::default_instance_;
  delete SymbolStatus::default_instance_;
  delete Entry::default_instance_;
  delete ConfigValue::default_instance_;
  delete Value::default_instance_;
  delete Item::default_instance_;
  delete CompoundValue::default_instance_;
  delete Reference::default_instance_;
  delete Id::default_instance_;
  delete String::default_instance_;
  delete RawString::default_instance_;
  delete StyledString::default_instance_;
  delete StyledString_Span::default_instance_;
  delete FileReference::default_instance_;
  delete Primitive::default_instance_;
  delete Attribute::default_instance_;
  delete Attribute_Symbol::default_instance_;
  delete Style::default_instance_;
  delete Style_Entry::default_instance_;
  delete Styleable::default_instance_;
  delete Styleable_Entry::default_instance_;
  delete Array::default_instance_;
  delete Array_Element::default_instance_;
  delete Plural::default_instance_;
  delete Plural_Entry::default_instance_;
  delete XmlNode::default_instance_;
  delete XmlElement::default_instance_;
  delete XmlNamespace::default_instance_;
  delete XmlAttribute::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ConfigDescription::default_instance_ = new ConfigDescription();
  StringPool::default_instance_ = new StringPool();
  SourcePosition::default_instance_ = new SourcePosition();
  Source::default_instance_ = new Source();
  ResourceTable::default_instance_ = new ResourceTable();
  Package::default_instance_ = new Package();
  Type::default_instance_ = new Type();
  SymbolStatus::default_instance_ = new SymbolStatus();
  Entry::default_instance_ = new Entry();
  ConfigValue::default_instance_ = new ConfigValue();
  Value::default_instance_ = new Value();
  Item::default_instance_ = new Item();
  CompoundValue::default_instance_ = new CompoundValue();
  Reference::default_instance_ = new Reference();
  Id::default_instance_ = new Id();
  String::default_instance_ = new String();
  RawString::default_instance_ = new RawString();
  StyledString::default_instance_ = new StyledString();
  StyledString_Span::default_instance_ = new StyledString_Span();
  FileReference::default_instance_ = new FileReference();
  Primitive::default_instance_ = new Primitive();
  Attribute::default_instance_ = new Attribute();
  Attribute_Symbol::default_instance_ = new Attribute_Symbol();
  Style::default_instance_ = new Style();
  Style_Entry::default_instance_ = new Style_Entry();
  Styleable::default_instance_ = new Styleable();
  Styleable_Entry::default_instance_ = new Styleable_Entry();
  Array::default_instance_ = new Array();
  Array_Element::default_instance_ = new Array_Element();
  Plural::default_instance_ = new Plural();
  Plural_Entry::default_instance_ = new Plural_Entry();
  XmlNode::default_instance_ = new XmlNode();
  XmlElement::default_instance_ = new XmlElement();
  XmlNamespace::default_instance_ = new XmlNamespace();
  XmlAttribute::default_instance_ = new XmlAttribute();
  ConfigDescription::default_instance_->InitAsDefaultInstance();
  StringPool::default_instance_->InitAsDefaultInstance();
  SourcePosition::default_instance_->InitAsDefaultInstance();
  Source::default_instance_->InitAsDefaultInstance();
  ResourceTable::default_instance_->InitAsDefaultInstance();
  Package::default_instance_->InitAsDefaultInstance();
  Type::default_instance_->InitAsDefaultInstance();
  SymbolStatus::default_instance_->InitAsDefaultInstance();
  Entry::default_instance_->InitAsDefaultInstance();
  ConfigValue::default_instance_->InitAsDefaultInstance();
  Value::default_instance_->InitAsDefaultInstance();
  Item::default_instance_->InitAsDefaultInstance();
  CompoundValue::default_instance_->InitAsDefaultInstance();
  Reference::default_instance_->InitAsDefaultInstance();
  Id::default_instance_->InitAsDefaultInstance();
  String::default_instance_->InitAsDefaultInstance();
  RawString::default_instance_->InitAsDefaultInstance();
  StyledString::default_instance_->InitAsDefaultInstance();
  StyledString_Span::default_instance_->InitAsDefaultInstance();
  FileReference::default_instance_->InitAsDefaultInstance();
  Primitive::default_instance_->InitAsDefaultInstance();
  Attribute::default_instance_->InitAsDefaultInstance();
  Attribute_Symbol::default_instance_->InitAsDefaultInstance();
  Style::default_instance_->InitAsDefaultInstance();
  Style_Entry::default_instance_->InitAsDefaultInstance();
  Styleable::default_instance_->InitAsDefaultInstance();
  Styleable_Entry::default_instance_->InitAsDefaultInstance();
  Array::default_instance_->InitAsDefaultInstance();
  Array_Element::default_instance_->InitAsDefaultInstance();
  Plural::default_instance_->InitAsDefaultInstance();
  Plural_Entry::default_instance_->InitAsDefaultInstance();
  XmlNode::default_instance_->InitAsDefaultInstance();
  XmlElement::default_instance_->InitAsDefaultInstance();
  XmlNamespace::default_instance_->InitAsDefaultInstance();
  XmlAttribute::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_once_);
void protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_once_,
                 &protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto {
  StaticDescriptorInitializer_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto() {
    protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  }
} static_descriptor_initializer_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForConfigDescription(
    ConfigDescription* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConfigDescription::kDataFieldNumber;
const int ConfigDescription::kProductFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConfigDescription::ConfigDescription()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.ConfigDescription)
}

void ConfigDescription::InitAsDefaultInstance() {
}

ConfigDescription::ConfigDescription(const ConfigDescription& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.ConfigDescription)
}

void ConfigDescription::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  product_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigDescription::~ConfigDescription() {
  // @@protoc_insertion_point(destructor:aapt.pb.ConfigDescription)
  SharedDtor();
}

void ConfigDescription::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  product_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigDescription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigDescription& ConfigDescription::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

ConfigDescription* ConfigDescription::default_instance_ = NULL;

ConfigDescription* ConfigDescription::New(::google::protobuf::Arena* arena) const {
  ConfigDescription* n = new ConfigDescription;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConfigDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.ConfigDescription)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_product()) {
      product_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ConfigDescription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForConfigDescription, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.ConfigDescription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_product;
        break;
      }

      // optional string product = 2;
      case 2: {
        if (tag == 18) {
         parse_product:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_product()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.ConfigDescription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.ConfigDescription)
  return false;
#undef DO_
}

void ConfigDescription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.ConfigDescription)
  // optional bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  // optional string product = 2;
  if (has_product()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->product(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.ConfigDescription)
}

int ConfigDescription::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.ConfigDescription)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional string product = 2;
    if (has_product()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->product());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigDescription::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigDescription*>(&from));
}

void ConfigDescription::MergeFrom(const ConfigDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.ConfigDescription)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_product()) {
      set_has_product();
      product_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.product_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ConfigDescription::CopyFrom(const ConfigDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.ConfigDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigDescription::IsInitialized() const {

  return true;
}

void ConfigDescription::Swap(ConfigDescription* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConfigDescription::InternalSwap(ConfigDescription* other) {
  data_.Swap(&other->data_);
  product_.Swap(&other->product_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ConfigDescription::GetTypeName() const {
  return "aapt.pb.ConfigDescription";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConfigDescription

// optional bytes data = 1;
bool ConfigDescription::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConfigDescription::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void ConfigDescription::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConfigDescription::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& ConfigDescription::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigDescription.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConfigDescription::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.ConfigDescription.data)
}
 void ConfigDescription::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.ConfigDescription.data)
}
 void ConfigDescription::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.ConfigDescription.data)
}
 ::std::string* ConfigDescription::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigDescription.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConfigDescription::release_data() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigDescription.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConfigDescription::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigDescription.data)
}

// optional string product = 2;
bool ConfigDescription::has_product() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConfigDescription::set_has_product() {
  _has_bits_[0] |= 0x00000002u;
}
void ConfigDescription::clear_has_product() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConfigDescription::clear_product() {
  product_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_product();
}
 const ::std::string& ConfigDescription::product() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigDescription.product)
  return product_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConfigDescription::set_product(const ::std::string& value) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.ConfigDescription.product)
}
 void ConfigDescription::set_product(const char* value) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.ConfigDescription.product)
}
 void ConfigDescription::set_product(const char* value, size_t size) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.ConfigDescription.product)
}
 ::std::string* ConfigDescription::mutable_product() {
  set_has_product();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigDescription.product)
  return product_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConfigDescription::release_product() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigDescription.product)
  clear_has_product();
  return product_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConfigDescription::set_allocated_product(::std::string* product) {
  if (product != NULL) {
    set_has_product();
  } else {
    clear_has_product();
  }
  product_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigDescription.product)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStringPool(
    StringPool* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringPool::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringPool::StringPool()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.StringPool)
}

void StringPool::InitAsDefaultInstance() {
}

StringPool::StringPool(const StringPool& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.StringPool)
}

void StringPool::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StringPool::~StringPool() {
  // @@protoc_insertion_point(destructor:aapt.pb.StringPool)
  SharedDtor();
}

void StringPool::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StringPool::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringPool& StringPool::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

StringPool* StringPool::default_instance_ = NULL;

StringPool* StringPool::New(::google::protobuf::Arena* arena) const {
  StringPool* n = new StringPool;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringPool::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.StringPool)
  if (has_data()) {
    data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool StringPool::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStringPool, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.StringPool)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.StringPool)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.StringPool)
  return false;
#undef DO_
}

void StringPool::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.StringPool)
  // optional bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.StringPool)
}

int StringPool::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StringPool)
  int total_size = 0;

  // optional bytes data = 1;
  if (has_data()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringPool::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringPool*>(&from));
}

void StringPool::MergeFrom(const StringPool& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StringPool)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void StringPool::CopyFrom(const StringPool& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StringPool)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringPool::IsInitialized() const {

  return true;
}

void StringPool::Swap(StringPool* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringPool::InternalSwap(StringPool* other) {
  data_.Swap(&other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringPool::GetTypeName() const {
  return "aapt.pb.StringPool";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringPool

// optional bytes data = 1;
bool StringPool::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StringPool::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void StringPool::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void StringPool::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& StringPool::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StringPool.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StringPool::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.StringPool.data)
}
 void StringPool::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.StringPool.data)
}
 void StringPool::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StringPool.data)
}
 ::std::string* StringPool::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StringPool.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StringPool::release_data() {
  // @@protoc_insertion_point(field_release:aapt.pb.StringPool.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StringPool::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StringPool.data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSourcePosition(
    SourcePosition* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SourcePosition::kLineNumberFieldNumber;
const int SourcePosition::kColumnNumberFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SourcePosition::SourcePosition()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.SourcePosition)
}

void SourcePosition::InitAsDefaultInstance() {
}

SourcePosition::SourcePosition(const SourcePosition& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.SourcePosition)
}

void SourcePosition::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_number_ = 0u;
  column_number_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SourcePosition::~SourcePosition() {
  // @@protoc_insertion_point(destructor:aapt.pb.SourcePosition)
  SharedDtor();
}

void SourcePosition::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SourcePosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SourcePosition& SourcePosition::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

SourcePosition* SourcePosition::default_instance_ = NULL;

SourcePosition* SourcePosition::New(::google::protobuf::Arena* arena) const {
  SourcePosition* n = new SourcePosition;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SourcePosition::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.SourcePosition)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SourcePosition, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SourcePosition*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(line_number_, column_number_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SourcePosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSourcePosition, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.SourcePosition)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 line_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &line_number_)));
          set_has_line_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_column_number;
        break;
      }

      // optional uint32 column_number = 2;
      case 2: {
        if (tag == 16) {
         parse_column_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &column_number_)));
          set_has_column_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.SourcePosition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.SourcePosition)
  return false;
#undef DO_
}

void SourcePosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.SourcePosition)
  // optional uint32 line_number = 1;
  if (has_line_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->line_number(), output);
  }

  // optional uint32 column_number = 2;
  if (has_column_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->column_number(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.SourcePosition)
}

int SourcePosition::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.SourcePosition)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 line_number = 1;
    if (has_line_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->line_number());
    }

    // optional uint32 column_number = 2;
    if (has_column_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->column_number());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SourcePosition::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SourcePosition*>(&from));
}

void SourcePosition::MergeFrom(const SourcePosition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.SourcePosition)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_line_number()) {
      set_line_number(from.line_number());
    }
    if (from.has_column_number()) {
      set_column_number(from.column_number());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SourcePosition::CopyFrom(const SourcePosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.SourcePosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourcePosition::IsInitialized() const {

  return true;
}

void SourcePosition::Swap(SourcePosition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SourcePosition::InternalSwap(SourcePosition* other) {
  std::swap(line_number_, other->line_number_);
  std::swap(column_number_, other->column_number_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SourcePosition::GetTypeName() const {
  return "aapt.pb.SourcePosition";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SourcePosition

// optional uint32 line_number = 1;
bool SourcePosition::has_line_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SourcePosition::set_has_line_number() {
  _has_bits_[0] |= 0x00000001u;
}
void SourcePosition::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000001u;
}
void SourcePosition::clear_line_number() {
  line_number_ = 0u;
  clear_has_line_number();
}
 ::google::protobuf::uint32 SourcePosition::line_number() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.line_number)
  return line_number_;
}
 void SourcePosition::set_line_number(::google::protobuf::uint32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.line_number)
}

// optional uint32 column_number = 2;
bool SourcePosition::has_column_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SourcePosition::set_has_column_number() {
  _has_bits_[0] |= 0x00000002u;
}
void SourcePosition::clear_has_column_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void SourcePosition::clear_column_number() {
  column_number_ = 0u;
  clear_has_column_number();
}
 ::google::protobuf::uint32 SourcePosition::column_number() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.column_number)
  return column_number_;
}
 void SourcePosition::set_column_number(::google::protobuf::uint32 value) {
  set_has_column_number();
  column_number_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.column_number)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSource(
    Source* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Source::kPathIdxFieldNumber;
const int Source::kPositionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Source::Source()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Source)
}

void Source::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  position_ = const_cast< ::aapt::pb::SourcePosition*>(
      ::aapt::pb::SourcePosition::internal_default_instance());
#else
  position_ = const_cast< ::aapt::pb::SourcePosition*>(&::aapt::pb::SourcePosition::default_instance());
#endif
}

Source::Source(const Source& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Source)
}

void Source::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  path_idx_ = 0u;
  position_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Source::~Source() {
  // @@protoc_insertion_point(destructor:aapt.pb.Source)
  SharedDtor();
}

void Source::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete position_;
  }
}

void Source::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Source& Source::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Source* Source::default_instance_ = NULL;

Source* Source::New(::google::protobuf::Arena* arena) const {
  Source* n = new Source;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Source::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Source)
  if (_has_bits_[0 / 32] & 3u) {
    path_idx_ = 0u;
    if (has_position()) {
      if (position_ != NULL) position_->::aapt::pb::SourcePosition::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Source::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Source)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 path_idx = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &path_idx_)));
          set_has_path_idx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_position;
        break;
      }

      // optional .aapt.pb.SourcePosition position = 2;
      case 2: {
        if (tag == 18) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Source)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Source)
  return false;
#undef DO_
}

void Source::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Source)
  // optional uint32 path_idx = 1;
  if (has_path_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->path_idx(), output);
  }

  // optional .aapt.pb.SourcePosition position = 2;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->position_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Source)
}

int Source::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Source)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 path_idx = 1;
    if (has_path_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->path_idx());
    }

    // optional .aapt.pb.SourcePosition position = 2;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Source::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Source*>(&from));
}

void Source::MergeFrom(const Source& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Source)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path_idx()) {
      set_path_idx(from.path_idx());
    }
    if (from.has_position()) {
      mutable_position()->::aapt::pb::SourcePosition::MergeFrom(from.position());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Source::CopyFrom(const Source& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Source)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Source::IsInitialized() const {

  return true;
}

void Source::Swap(Source* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Source::InternalSwap(Source* other) {
  std::swap(path_idx_, other->path_idx_);
  std::swap(position_, other->position_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Source::GetTypeName() const {
  return "aapt.pb.Source";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Source

// optional uint32 path_idx = 1;
bool Source::has_path_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Source::set_has_path_idx() {
  _has_bits_[0] |= 0x00000001u;
}
void Source::clear_has_path_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
void Source::clear_path_idx() {
  path_idx_ = 0u;
  clear_has_path_idx();
}
 ::google::protobuf::uint32 Source::path_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.path_idx)
  return path_idx_;
}
 void Source::set_path_idx(::google::protobuf::uint32 value) {
  set_has_path_idx();
  path_idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Source.path_idx)
}

// optional .aapt.pb.SourcePosition position = 2;
bool Source::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Source::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
void Source::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
void Source::clear_position() {
  if (position_ != NULL) position_->::aapt::pb::SourcePosition::Clear();
  clear_has_position();
}
const ::aapt::pb::SourcePosition& Source::position() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.position)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_ != NULL ? *position_ : *default_instance().position_;
#else
  return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
}
::aapt::pb::SourcePosition* Source::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Source.position)
  return position_;
}
::aapt::pb::SourcePosition* Source::release_position() {
  // @@protoc_insertion_point(field_release:aapt.pb.Source.position)
  clear_has_position();
  ::aapt::pb::SourcePosition* temp = position_;
  position_ = NULL;
  return temp;
}
void Source::set_allocated_position(::aapt::pb::SourcePosition* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Source.position)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForResourceTable(
    ResourceTable* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResourceTable::kSourcePoolFieldNumber;
const int ResourceTable::kPackageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResourceTable::ResourceTable()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.ResourceTable)
}

void ResourceTable::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_pool_ = const_cast< ::aapt::pb::StringPool*>(
      ::aapt::pb::StringPool::internal_default_instance());
#else
  source_pool_ = const_cast< ::aapt::pb::StringPool*>(&::aapt::pb::StringPool::default_instance());
#endif
}

ResourceTable::ResourceTable(const ResourceTable& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.ResourceTable)
}

void ResourceTable::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_pool_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceTable::~ResourceTable() {
  // @@protoc_insertion_point(destructor:aapt.pb.ResourceTable)
  SharedDtor();
}

void ResourceTable::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_pool_;
  }
}

void ResourceTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResourceTable& ResourceTable::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

ResourceTable* ResourceTable::default_instance_ = NULL;

ResourceTable* ResourceTable::New(::google::protobuf::Arena* arena) const {
  ResourceTable* n = new ResourceTable;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResourceTable::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.ResourceTable)
  if (has_source_pool()) {
    if (source_pool_ != NULL) source_pool_->::aapt::pb::StringPool::Clear();
  }
  package_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ResourceTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForResourceTable, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.ResourceTable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.StringPool source_pool = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source_pool()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_package;
        break;
      }

      // repeated .aapt.pb.Package package = 2;
      case 2: {
        if (tag == 18) {
         parse_package:
          DO_(input->IncrementRecursionDepth());
         parse_loop_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_package()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_package;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.ResourceTable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.ResourceTable)
  return false;
#undef DO_
}

void ResourceTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.ResourceTable)
  // optional .aapt.pb.StringPool source_pool = 1;
  if (has_source_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_pool_, output);
  }

  // repeated .aapt.pb.Package package = 2;
  for (unsigned int i = 0, n = this->package_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->package(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.ResourceTable)
}

int ResourceTable::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.ResourceTable)
  int total_size = 0;

  // optional .aapt.pb.StringPool source_pool = 1;
  if (has_source_pool()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->source_pool_);
  }

  // repeated .aapt.pb.Package package = 2;
  total_size += 1 * this->package_size();
  for (int i = 0; i < this->package_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->package(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceTable::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResourceTable*>(&from));
}

void ResourceTable::MergeFrom(const ResourceTable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.ResourceTable)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  package_.MergeFrom(from.package_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source_pool()) {
      mutable_source_pool()->::aapt::pb::StringPool::MergeFrom(from.source_pool());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ResourceTable::CopyFrom(const ResourceTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.ResourceTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceTable::IsInitialized() const {

  return true;
}

void ResourceTable::Swap(ResourceTable* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResourceTable::InternalSwap(ResourceTable* other) {
  std::swap(source_pool_, other->source_pool_);
  package_.UnsafeArenaSwap(&other->package_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ResourceTable::GetTypeName() const {
  return "aapt.pb.ResourceTable";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResourceTable

// optional .aapt.pb.StringPool source_pool = 1;
bool ResourceTable::has_source_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResourceTable::set_has_source_pool() {
  _has_bits_[0] |= 0x00000001u;
}
void ResourceTable::clear_has_source_pool() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResourceTable::clear_source_pool() {
  if (source_pool_ != NULL) source_pool_->::aapt::pb::StringPool::Clear();
  clear_has_source_pool();
}
const ::aapt::pb::StringPool& ResourceTable::source_pool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.source_pool)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_pool_ != NULL ? *source_pool_ : *default_instance().source_pool_;
#else
  return source_pool_ != NULL ? *source_pool_ : *default_instance_->source_pool_;
#endif
}
::aapt::pb::StringPool* ResourceTable::mutable_source_pool() {
  set_has_source_pool();
  if (source_pool_ == NULL) {
    source_pool_ = new ::aapt::pb::StringPool;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.source_pool)
  return source_pool_;
}
::aapt::pb::StringPool* ResourceTable::release_source_pool() {
  // @@protoc_insertion_point(field_release:aapt.pb.ResourceTable.source_pool)
  clear_has_source_pool();
  ::aapt::pb::StringPool* temp = source_pool_;
  source_pool_ = NULL;
  return temp;
}
void ResourceTable::set_allocated_source_pool(::aapt::pb::StringPool* source_pool) {
  delete source_pool_;
  source_pool_ = source_pool;
  if (source_pool) {
    set_has_source_pool();
  } else {
    clear_has_source_pool();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.source_pool)
}

// repeated .aapt.pb.Package package = 2;
int ResourceTable::package_size() const {
  return package_.size();
}
void ResourceTable::clear_package() {
  package_.Clear();
}
const ::aapt::pb::Package& ResourceTable::package(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.package)
  return package_.Get(index);
}
::aapt::pb::Package* ResourceTable::mutable_package(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.package)
  return package_.Mutable(index);
}
::aapt::pb::Package* ResourceTable::add_package() {
  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.package)
  return package_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >*
ResourceTable::mutable_package() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.package)
  return &package_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >&
ResourceTable::package() const {
  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.package)
  return package_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForPackage(
    Package* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Package::kPackageIdFieldNumber;
const int Package::kPackageNameFieldNumber;
const int Package::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Package::Package()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Package)
}

void Package::InitAsDefaultInstance() {
}

Package::Package(const Package& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Package)
}

void Package::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  package_id_ = 0u;
  package_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Package::~Package() {
  // @@protoc_insertion_point(destructor:aapt.pb.Package)
  SharedDtor();
}

void Package::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  package_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Package::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Package& Package::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Package* Package::default_instance_ = NULL;

Package* Package::New(::google::protobuf::Arena* arena) const {
  Package* n = new Package;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Package::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Package)
  if (_has_bits_[0 / 32] & 3u) {
    package_id_ = 0u;
    if (has_package_name()) {
      package_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Package::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPackage, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Package)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 package_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &package_id_)));
          set_has_package_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_package_name;
        break;
      }

      // optional string package_name = 2;
      case 2: {
        if (tag == 18) {
         parse_package_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_type;
        break;
      }

      // repeated .aapt.pb.Type type = 3;
      case 3: {
        if (tag == 26) {
         parse_type:
          DO_(input->IncrementRecursionDepth());
         parse_loop_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_type;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Package)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Package)
  return false;
#undef DO_
}

void Package::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Package)
  // optional uint32 package_id = 1;
  if (has_package_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->package_id(), output);
  }

  // optional string package_name = 2;
  if (has_package_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->package_name(), output);
  }

  // repeated .aapt.pb.Type type = 3;
  for (unsigned int i = 0, n = this->type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->type(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Package)
}

int Package::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Package)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 package_id = 1;
    if (has_package_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->package_id());
    }

    // optional string package_name = 2;
    if (has_package_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_name());
    }

  }
  // repeated .aapt.pb.Type type = 3;
  total_size += 1 * this->type_size();
  for (int i = 0; i < this->type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->type(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Package::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Package*>(&from));
}

void Package::MergeFrom(const Package& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Package)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  type_.MergeFrom(from.type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_id()) {
      set_package_id(from.package_id());
    }
    if (from.has_package_name()) {
      set_has_package_name();
      package_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.package_name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Package::CopyFrom(const Package& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Package)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Package::IsInitialized() const {

  return true;
}

void Package::Swap(Package* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Package::InternalSwap(Package* other) {
  std::swap(package_id_, other->package_id_);
  package_name_.Swap(&other->package_name_);
  type_.UnsafeArenaSwap(&other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Package::GetTypeName() const {
  return "aapt.pb.Package";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Package

// optional uint32 package_id = 1;
bool Package::has_package_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Package::set_has_package_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Package::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Package::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
 ::google::protobuf::uint32 Package::package_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_id)
  return package_id_;
}
 void Package::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_id)
}

// optional string package_name = 2;
bool Package::has_package_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Package::set_has_package_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Package::clear_has_package_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Package::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_package_name();
}
 const ::std::string& Package::package_name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_name)
  return package_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Package::set_package_name(const ::std::string& value) {
  set_has_package_name();
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_name)
}
 void Package::set_package_name(const char* value) {
  set_has_package_name();
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Package.package_name)
}
 void Package::set_package_name(const char* value, size_t size) {
  set_has_package_name();
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Package.package_name)
}
 ::std::string* Package::mutable_package_name() {
  set_has_package_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_name)
  return package_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Package::release_package_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Package.package_name)
  clear_has_package_name();
  return package_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Package::set_allocated_package_name(::std::string* package_name) {
  if (package_name != NULL) {
    set_has_package_name();
  } else {
    clear_has_package_name();
  }
  package_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_name)
}

// repeated .aapt.pb.Type type = 3;
int Package::type_size() const {
  return type_.size();
}
void Package::clear_type() {
  type_.Clear();
}
const ::aapt::pb::Type& Package::type(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.type)
  return type_.Get(index);
}
::aapt::pb::Type* Package::mutable_type(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.type)
  return type_.Mutable(index);
}
::aapt::pb::Type* Package::add_type() {
  // @@protoc_insertion_point(field_add:aapt.pb.Package.type)
  return type_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >*
Package::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Package.type)
  return &type_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >&
Package::type() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Package.type)
  return type_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForType(
    Type* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Type::kIdFieldNumber;
const int Type::kNameFieldNumber;
const int Type::kEntryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Type::Type()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Type)
}

void Type::InitAsDefaultInstance() {
}

Type::Type(const Type& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Type)
}

void Type::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0u;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Type::~Type() {
  // @@protoc_insertion_point(destructor:aapt.pb.Type)
  SharedDtor();
}

void Type::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Type::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Type& Type::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Type* Type::default_instance_ = NULL;

Type* Type::New(::google::protobuf::Arena* arena) const {
  Type* n = new Type;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Type::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Type)
  if (_has_bits_[0 / 32] & 3u) {
    id_ = 0u;
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  entry_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Type::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForType, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Type)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entry;
        break;
      }

      // repeated .aapt.pb.Entry entry = 3;
      case 3: {
        if (tag == 26) {
         parse_entry:
          DO_(input->IncrementRecursionDepth());
         parse_loop_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_entry;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Type)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Type)
  return false;
#undef DO_
}

void Type::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Type)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // repeated .aapt.pb.Entry entry = 3;
  for (unsigned int i = 0, n = this->entry_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->entry(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Type)
}

int Type::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Type)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .aapt.pb.Entry entry = 3;
  total_size += 1 * this->entry_size();
  for (int i = 0; i < this->entry_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entry(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Type::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Type*>(&from));
}

void Type::MergeFrom(const Type& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Type)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  entry_.MergeFrom(from.entry_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Type::CopyFrom(const Type& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Type)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Type::IsInitialized() const {

  return true;
}

void Type::Swap(Type* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Type::InternalSwap(Type* other) {
  std::swap(id_, other->id_);
  name_.Swap(&other->name_);
  entry_.UnsafeArenaSwap(&other->entry_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Type::GetTypeName() const {
  return "aapt.pb.Type";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Type

// optional uint32 id = 1;
bool Type::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Type::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Type::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Type::clear_id() {
  id_ = 0u;
  clear_has_id();
}
 ::google::protobuf::uint32 Type::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.id)
  return id_;
}
 void Type::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Type.id)
}

// optional string name = 2;
bool Type::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Type::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Type::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Type::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Type::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Type.name)
}
 void Type::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Type.name)
}
 void Type::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Type.name)
}
 ::std::string* Type::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Type.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Type::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.name)
}

// repeated .aapt.pb.Entry entry = 3;
int Type::entry_size() const {
  return entry_.size();
}
void Type::clear_entry() {
  entry_.Clear();
}
const ::aapt::pb::Entry& Type::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.entry)
  return entry_.Get(index);
}
::aapt::pb::Entry* Type::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.entry)
  return entry_.Mutable(index);
}
::aapt::pb::Entry* Type::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Type.entry)
  return entry_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >*
Type::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Type.entry)
  return &entry_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >&
Type::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Type.entry)
  return entry_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSymbolStatus(
    SymbolStatus* ptr) {
  return ptr->mutable_unknown_fields();
}

bool SymbolStatus_Visibility_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const SymbolStatus_Visibility SymbolStatus::UNKNOWN;
const SymbolStatus_Visibility SymbolStatus::PRIVATE;
const SymbolStatus_Visibility SymbolStatus::PUBLIC;
const SymbolStatus_Visibility SymbolStatus::Visibility_MIN;
const SymbolStatus_Visibility SymbolStatus::Visibility_MAX;
const int SymbolStatus::Visibility_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SymbolStatus::kVisibilityFieldNumber;
const int SymbolStatus::kSourceFieldNumber;
const int SymbolStatus::kCommentFieldNumber;
const int SymbolStatus::kAllowNewFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SymbolStatus::SymbolStatus()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.SymbolStatus)
}

void SymbolStatus::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
}

SymbolStatus::SymbolStatus(const SymbolStatus& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.SymbolStatus)
}

void SymbolStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  visibility_ = 0;
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  allow_new_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SymbolStatus::~SymbolStatus() {
  // @@protoc_insertion_point(destructor:aapt.pb.SymbolStatus)
  SharedDtor();
}

void SymbolStatus::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
  }
}

void SymbolStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SymbolStatus& SymbolStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

SymbolStatus* SymbolStatus::default_instance_ = NULL;

SymbolStatus* SymbolStatus::New(::google::protobuf::Arena* arena) const {
  SymbolStatus* n = new SymbolStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SymbolStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.SymbolStatus)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SymbolStatus, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SymbolStatus*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(visibility_, allow_new_);
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SymbolStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSymbolStatus, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.SymbolStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aapt::pb::SymbolStatus_Visibility_IsValid(value)) {
            set_visibility(static_cast< ::aapt::pb::SymbolStatus_Visibility >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source;
        break;
      }

      // optional .aapt.pb.Source source = 2;
      case 2: {
        if (tag == 18) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_comment;
        break;
      }

      // optional string comment = 3;
      case 3: {
        if (tag == 26) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_allow_new;
        break;
      }

      // optional bool allow_new = 4;
      case 4: {
        if (tag == 32) {
         parse_allow_new:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_new_)));
          set_has_allow_new();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.SymbolStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.SymbolStatus)
  return false;
#undef DO_
}

void SymbolStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.SymbolStatus)
  // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->visibility(), output);
  }

  // optional .aapt.pb.Source source = 2;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->source_, output);
  }

  // optional string comment = 3;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->comment(), output);
  }

  // optional bool allow_new = 4;
  if (has_allow_new()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->allow_new(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.SymbolStatus)
}

int SymbolStatus::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.SymbolStatus)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
    if (has_visibility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visibility());
    }

    // optional .aapt.pb.Source source = 2;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 3;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional bool allow_new = 4;
    if (has_allow_new()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SymbolStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SymbolStatus*>(&from));
}

void SymbolStatus::MergeFrom(const SymbolStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.SymbolStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_allow_new()) {
      set_allow_new(from.allow_new());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SymbolStatus::CopyFrom(const SymbolStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.SymbolStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymbolStatus::IsInitialized() const {

  return true;
}

void SymbolStatus::Swap(SymbolStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SymbolStatus::InternalSwap(SymbolStatus* other) {
  std::swap(visibility_, other->visibility_);
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(allow_new_, other->allow_new_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SymbolStatus::GetTypeName() const {
  return "aapt.pb.SymbolStatus";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SymbolStatus

// optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
bool SymbolStatus::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SymbolStatus::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
void SymbolStatus::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
void SymbolStatus::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
 ::aapt::pb::SymbolStatus_Visibility SymbolStatus::visibility() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.visibility)
  return static_cast< ::aapt::pb::SymbolStatus_Visibility >(visibility_);
}
 void SymbolStatus::set_visibility(::aapt::pb::SymbolStatus_Visibility value) {
  assert(::aapt::pb::SymbolStatus_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.visibility)
}

// optional .aapt.pb.Source source = 2;
bool SymbolStatus::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SymbolStatus::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
void SymbolStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
void SymbolStatus::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& SymbolStatus::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* SymbolStatus::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.SymbolStatus.source)
  return source_;
}
::aapt::pb::Source* SymbolStatus::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.SymbolStatus.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void SymbolStatus::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.SymbolStatus.source)
}

// optional string comment = 3;
bool SymbolStatus::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SymbolStatus::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
void SymbolStatus::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
void SymbolStatus::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& SymbolStatus::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymbolStatus::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.comment)
}
 void SymbolStatus::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.SymbolStatus.comment)
}
 void SymbolStatus::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.SymbolStatus.comment)
}
 ::std::string* SymbolStatus::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.SymbolStatus.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SymbolStatus::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.SymbolStatus.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SymbolStatus::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.SymbolStatus.comment)
}

// optional bool allow_new = 4;
bool SymbolStatus::has_allow_new() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SymbolStatus::set_has_allow_new() {
  _has_bits_[0] |= 0x00000008u;
}
void SymbolStatus::clear_has_allow_new() {
  _has_bits_[0] &= ~0x00000008u;
}
void SymbolStatus::clear_allow_new() {
  allow_new_ = false;
  clear_has_allow_new();
}
 bool SymbolStatus::allow_new() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.allow_new)
  return allow_new_;
}
 void SymbolStatus::set_allow_new(bool value) {
  set_has_allow_new();
  allow_new_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.allow_new)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForEntry(
    Entry* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Entry::kIdFieldNumber;
const int Entry::kNameFieldNumber;
const int Entry::kSymbolStatusFieldNumber;
const int Entry::kConfigValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Entry::Entry()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Entry)
}

void Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  symbol_status_ = const_cast< ::aapt::pb::SymbolStatus*>(
      ::aapt::pb::SymbolStatus::internal_default_instance());
#else
  symbol_status_ = const_cast< ::aapt::pb::SymbolStatus*>(&::aapt::pb::SymbolStatus::default_instance());
#endif
}

Entry::Entry(const Entry& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Entry)
}

void Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0u;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  symbol_status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entry::~Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Entry)
  SharedDtor();
}

void Entry::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete symbol_status_;
  }
}

void Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Entry& Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Entry* Entry::default_instance_ = NULL;

Entry* Entry::New(::google::protobuf::Arena* arena) const {
  Entry* n = new Entry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Entry)
  if (_has_bits_[0 / 32] & 7u) {
    id_ = 0u;
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_symbol_status()) {
      if (symbol_status_ != NULL) symbol_status_->::aapt::pb::SymbolStatus::Clear();
    }
  }
  config_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForEntry, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_symbol_status;
        break;
      }

      // optional .aapt.pb.SymbolStatus symbol_status = 3;
      case 3: {
        if (tag == 26) {
         parse_symbol_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_symbol_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_config_value;
        break;
      }

      // repeated .aapt.pb.ConfigValue config_value = 4;
      case 4: {
        if (tag == 34) {
         parse_config_value:
          DO_(input->IncrementRecursionDepth());
         parse_loop_config_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_config_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_config_value;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Entry)
  return false;
#undef DO_
}

void Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Entry)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional .aapt.pb.SymbolStatus symbol_status = 3;
  if (has_symbol_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->symbol_status_, output);
  }

  // repeated .aapt.pb.ConfigValue config_value = 4;
  for (unsigned int i = 0, n = this->config_value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->config_value(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Entry)
}

int Entry::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Entry)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .aapt.pb.SymbolStatus symbol_status = 3;
    if (has_symbol_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->symbol_status_);
    }

  }
  // repeated .aapt.pb.ConfigValue config_value = 4;
  total_size += 1 * this->config_value_size();
  for (int i = 0; i < this->config_value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->config_value(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Entry*>(&from));
}

void Entry::MergeFrom(const Entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Entry)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  config_value_.MergeFrom(from.config_value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_symbol_status()) {
      mutable_symbol_status()->::aapt::pb::SymbolStatus::MergeFrom(from.symbol_status());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Entry::CopyFrom(const Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entry::IsInitialized() const {

  return true;
}

void Entry::Swap(Entry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Entry::InternalSwap(Entry* other) {
  std::swap(id_, other->id_);
  name_.Swap(&other->name_);
  std::swap(symbol_status_, other->symbol_status_);
  config_value_.UnsafeArenaSwap(&other->config_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Entry::GetTypeName() const {
  return "aapt.pb.Entry";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Entry

// optional uint32 id = 1;
bool Entry::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Entry::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Entry::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Entry::clear_id() {
  id_ = 0u;
  clear_has_id();
}
 ::google::protobuf::uint32 Entry::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.id)
  return id_;
}
 void Entry::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.id)
}

// optional string name = 2;
bool Entry::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Entry::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Entry::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Entry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Entry::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entry::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.name)
}
 void Entry::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Entry.name)
}
 void Entry::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Entry.name)
}
 ::std::string* Entry::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entry::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.name)
}

// optional .aapt.pb.SymbolStatus symbol_status = 3;
bool Entry::has_symbol_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Entry::set_has_symbol_status() {
  _has_bits_[0] |= 0x00000004u;
}
void Entry::clear_has_symbol_status() {
  _has_bits_[0] &= ~0x00000004u;
}
void Entry::clear_symbol_status() {
  if (symbol_status_ != NULL) symbol_status_->::aapt::pb::SymbolStatus::Clear();
  clear_has_symbol_status();
}
const ::aapt::pb::SymbolStatus& Entry::symbol_status() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.symbol_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return symbol_status_ != NULL ? *symbol_status_ : *default_instance().symbol_status_;
#else
  return symbol_status_ != NULL ? *symbol_status_ : *default_instance_->symbol_status_;
#endif
}
::aapt::pb::SymbolStatus* Entry::mutable_symbol_status() {
  set_has_symbol_status();
  if (symbol_status_ == NULL) {
    symbol_status_ = new ::aapt::pb::SymbolStatus;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.symbol_status)
  return symbol_status_;
}
::aapt::pb::SymbolStatus* Entry::release_symbol_status() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.symbol_status)
  clear_has_symbol_status();
  ::aapt::pb::SymbolStatus* temp = symbol_status_;
  symbol_status_ = NULL;
  return temp;
}
void Entry::set_allocated_symbol_status(::aapt::pb::SymbolStatus* symbol_status) {
  delete symbol_status_;
  symbol_status_ = symbol_status;
  if (symbol_status) {
    set_has_symbol_status();
  } else {
    clear_has_symbol_status();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.symbol_status)
}

// repeated .aapt.pb.ConfigValue config_value = 4;
int Entry::config_value_size() const {
  return config_value_.size();
}
void Entry::clear_config_value() {
  config_value_.Clear();
}
const ::aapt::pb::ConfigValue& Entry::config_value(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.config_value)
  return config_value_.Get(index);
}
::aapt::pb::ConfigValue* Entry::mutable_config_value(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.config_value)
  return config_value_.Mutable(index);
}
::aapt::pb::ConfigValue* Entry::add_config_value() {
  // @@protoc_insertion_point(field_add:aapt.pb.Entry.config_value)
  return config_value_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >*
Entry::mutable_config_value() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Entry.config_value)
  return &config_value_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >&
Entry::config_value() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Entry.config_value)
  return config_value_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForConfigValue(
    ConfigValue* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConfigValue::kConfigFieldNumber;
const int ConfigValue::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConfigValue::ConfigValue()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.ConfigValue)
}

void ConfigValue::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::aapt::pb::ConfigDescription*>(
      ::aapt::pb::ConfigDescription::internal_default_instance());
#else
  config_ = const_cast< ::aapt::pb::ConfigDescription*>(&::aapt::pb::ConfigDescription::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  value_ = const_cast< ::aapt::pb::Value*>(
      ::aapt::pb::Value::internal_default_instance());
#else
  value_ = const_cast< ::aapt::pb::Value*>(&::aapt::pb::Value::default_instance());
#endif
}

ConfigValue::ConfigValue(const ConfigValue& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.ConfigValue)
}

void ConfigValue::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  config_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigValue::~ConfigValue() {
  // @@protoc_insertion_point(destructor:aapt.pb.ConfigValue)
  SharedDtor();
}

void ConfigValue::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
    delete value_;
  }
}

void ConfigValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigValue& ConfigValue::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

ConfigValue* ConfigValue::default_instance_ = NULL;

ConfigValue* ConfigValue::New(::google::protobuf::Arena* arena) const {
  ConfigValue* n = new ConfigValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConfigValue::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.ConfigValue)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_config()) {
      if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::aapt::pb::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ConfigValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForConfigValue, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.ConfigValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.ConfigDescription config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .aapt.pb.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.ConfigValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.ConfigValue)
  return false;
#undef DO_
}

void ConfigValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.ConfigValue)
  // optional .aapt.pb.ConfigDescription config = 1;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->config_, output);
  }

  // optional .aapt.pb.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->value_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.ConfigValue)
}

int ConfigValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.ConfigValue)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .aapt.pb.ConfigDescription config = 1;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->config_);
    }

    // optional .aapt.pb.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigValue*>(&from));
}

void ConfigValue::MergeFrom(const ConfigValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.ConfigValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_config()) {
      mutable_config()->::aapt::pb::ConfigDescription::MergeFrom(from.config());
    }
    if (from.has_value()) {
      mutable_value()->::aapt::pb::Value::MergeFrom(from.value());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ConfigValue::CopyFrom(const ConfigValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.ConfigValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigValue::IsInitialized() const {

  return true;
}

void ConfigValue::Swap(ConfigValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConfigValue::InternalSwap(ConfigValue* other) {
  std::swap(config_, other->config_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ConfigValue::GetTypeName() const {
  return "aapt.pb.ConfigValue";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConfigValue

// optional .aapt.pb.ConfigDescription config = 1;
bool ConfigValue::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConfigValue::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
void ConfigValue::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConfigValue::clear_config() {
  if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
  clear_has_config();
}
const ::aapt::pb::ConfigDescription& ConfigValue::config() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
::aapt::pb::ConfigDescription* ConfigValue::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::aapt::pb::ConfigDescription;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.config)
  return config_;
}
::aapt::pb::ConfigDescription* ConfigValue::release_config() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.config)
  clear_has_config();
  ::aapt::pb::ConfigDescription* temp = config_;
  config_ = NULL;
  return temp;
}
void ConfigValue::set_allocated_config(::aapt::pb::ConfigDescription* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.config)
}

// optional .aapt.pb.Value value = 2;
bool ConfigValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConfigValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void ConfigValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConfigValue::clear_value() {
  if (value_ != NULL) value_->::aapt::pb::Value::Clear();
  clear_has_value();
}
const ::aapt::pb::Value& ConfigValue::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.value)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return value_ != NULL ? *value_ : *default_instance().value_;
#else
  return value_ != NULL ? *value_ : *default_instance_->value_;
#endif
}
::aapt::pb::Value* ConfigValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::aapt::pb::Value;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.value)
  return value_;
}
::aapt::pb::Value* ConfigValue::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.value)
  clear_has_value();
  ::aapt::pb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
void ConfigValue::set_allocated_value(::aapt::pb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForValue(
    Value* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value::kSourceFieldNumber;
const int Value::kCommentFieldNumber;
const int Value::kWeakFieldNumber;
const int Value::kItemFieldNumber;
const int Value::kCompoundValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value::Value()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Value)
}

void Value::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  compound_value_ = const_cast< ::aapt::pb::CompoundValue*>(
      ::aapt::pb::CompoundValue::internal_default_instance());
#else
  compound_value_ = const_cast< ::aapt::pb::CompoundValue*>(&::aapt::pb::CompoundValue::default_instance());
#endif
}

Value::Value(const Value& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Value)
}

void Value::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weak_ = false;
  item_ = NULL;
  compound_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value::~Value() {
  // @@protoc_insertion_point(destructor:aapt.pb.Value)
  SharedDtor();
}

void Value::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete item_;
    delete compound_value_;
  }
}

void Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Value& Value::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Value* Value::default_instance_ = NULL;

Value* Value::New(::google::protobuf::Arena* arena) const {
  Value* n = new Value;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Value)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    weak_ = false;
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
    if (has_compound_value()) {
      if (compound_value_ != NULL) compound_value_->::aapt::pb::CompoundValue::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForValue, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Value)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_weak;
        break;
      }

      // optional bool weak = 3;
      case 3: {
        if (tag == 24) {
         parse_weak:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &weak_)));
          set_has_weak();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 4;
      case 4: {
        if (tag == 34) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_compound_value;
        break;
      }

      // optional .aapt.pb.CompoundValue compound_value = 5;
      case 5: {
        if (tag == 42) {
         parse_compound_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compound_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Value)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Value)
  return false;
#undef DO_
}

void Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Value)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_, output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional bool weak = 3;
  if (has_weak()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->weak(), output);
  }

  // optional .aapt.pb.Item item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->item_, output);
  }

  // optional .aapt.pb.CompoundValue compound_value = 5;
  if (has_compound_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->compound_value_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Value)
}

int Value::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Value)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional bool weak = 3;
    if (has_weak()) {
      total_size += 1 + 1;
    }

    // optional .aapt.pb.Item item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->item_);
    }

    // optional .aapt.pb.CompoundValue compound_value = 5;
    if (has_compound_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->compound_value_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Value*>(&from));
}

void Value::MergeFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Value)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_weak()) {
      set_weak(from.weak());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
    if (from.has_compound_value()) {
      mutable_compound_value()->::aapt::pb::CompoundValue::MergeFrom(from.compound_value());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Value::CopyFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {

  return true;
}

void Value::Swap(Value* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value::InternalSwap(Value* other) {
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(weak_, other->weak_);
  std::swap(item_, other->item_);
  std::swap(compound_value_, other->compound_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Value::GetTypeName() const {
  return "aapt.pb.Value";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Value

// optional .aapt.pb.Source source = 1;
bool Value::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Value::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void Value::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void Value::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& Value::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* Value::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.source)
  return source_;
}
::aapt::pb::Source* Value::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Value::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.source)
}

// optional string comment = 2;
bool Value::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Value::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
void Value::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Value::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& Value::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Value::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Value.comment)
}
 void Value::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Value.comment)
}
 void Value::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Value.comment)
}
 ::std::string* Value::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Value::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Value::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.comment)
}

// optional bool weak = 3;
bool Value::has_weak() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Value::set_has_weak() {
  _has_bits_[0] |= 0x00000004u;
}
void Value::clear_has_weak() {
  _has_bits_[0] &= ~0x00000004u;
}
void Value::clear_weak() {
  weak_ = false;
  clear_has_weak();
}
 bool Value::weak() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.weak)
  return weak_;
}
 void Value::set_weak(bool value) {
  set_has_weak();
  weak_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Value.weak)
}

// optional .aapt.pb.Item item = 4;
bool Value::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Value::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
void Value::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
void Value::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
const ::aapt::pb::Item& Value::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
::aapt::pb::Item* Value::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.item)
  return item_;
}
::aapt::pb::Item* Value::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
void Value::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.item)
}

// optional .aapt.pb.CompoundValue compound_value = 5;
bool Value::has_compound_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Value::set_has_compound_value() {
  _has_bits_[0] |= 0x00000010u;
}
void Value::clear_has_compound_value() {
  _has_bits_[0] &= ~0x00000010u;
}
void Value::clear_compound_value() {
  if (compound_value_ != NULL) compound_value_->::aapt::pb::CompoundValue::Clear();
  clear_has_compound_value();
}
const ::aapt::pb::CompoundValue& Value::compound_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.compound_value)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compound_value_ != NULL ? *compound_value_ : *default_instance().compound_value_;
#else
  return compound_value_ != NULL ? *compound_value_ : *default_instance_->compound_value_;
#endif
}
::aapt::pb::CompoundValue* Value::mutable_compound_value() {
  set_has_compound_value();
  if (compound_value_ == NULL) {
    compound_value_ = new ::aapt::pb::CompoundValue;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.compound_value)
  return compound_value_;
}
::aapt::pb::CompoundValue* Value::release_compound_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.compound_value)
  clear_has_compound_value();
  ::aapt::pb::CompoundValue* temp = compound_value_;
  compound_value_ = NULL;
  return temp;
}
void Value::set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value) {
  delete compound_value_;
  compound_value_ = compound_value;
  if (compound_value) {
    set_has_compound_value();
  } else {
    clear_has_compound_value();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.compound_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForItem(
    Item* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Item::kRefFieldNumber;
const int Item::kStrFieldNumber;
const int Item::kRawStrFieldNumber;
const int Item::kStyledStrFieldNumber;
const int Item::kFileFieldNumber;
const int Item::kIdFieldNumber;
const int Item::kPrimFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Item::Item()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Item)
}

void Item::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ref_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  ref_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  str_ = const_cast< ::aapt::pb::String*>(
      ::aapt::pb::String::internal_default_instance());
#else
  str_ = const_cast< ::aapt::pb::String*>(&::aapt::pb::String::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  raw_str_ = const_cast< ::aapt::pb::RawString*>(
      ::aapt::pb::RawString::internal_default_instance());
#else
  raw_str_ = const_cast< ::aapt::pb::RawString*>(&::aapt::pb::RawString::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  styled_str_ = const_cast< ::aapt::pb::StyledString*>(
      ::aapt::pb::StyledString::internal_default_instance());
#else
  styled_str_ = const_cast< ::aapt::pb::StyledString*>(&::aapt::pb::StyledString::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  file_ = const_cast< ::aapt::pb::FileReference*>(
      ::aapt::pb::FileReference::internal_default_instance());
#else
  file_ = const_cast< ::aapt::pb::FileReference*>(&::aapt::pb::FileReference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aapt::pb::Id*>(
      ::aapt::pb::Id::internal_default_instance());
#else
  id_ = const_cast< ::aapt::pb::Id*>(&::aapt::pb::Id::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  prim_ = const_cast< ::aapt::pb::Primitive*>(
      ::aapt::pb::Primitive::internal_default_instance());
#else
  prim_ = const_cast< ::aapt::pb::Primitive*>(&::aapt::pb::Primitive::default_instance());
#endif
}

Item::Item(const Item& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Item)
}

void Item::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ref_ = NULL;
  str_ = NULL;
  raw_str_ = NULL;
  styled_str_ = NULL;
  file_ = NULL;
  id_ = NULL;
  prim_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Item::~Item() {
  // @@protoc_insertion_point(destructor:aapt.pb.Item)
  SharedDtor();
}

void Item::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ref_;
    delete str_;
    delete raw_str_;
    delete styled_str_;
    delete file_;
    delete id_;
    delete prim_;
  }
}

void Item::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Item& Item::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Item* Item::default_instance_ = NULL;

Item* Item::New(::google::protobuf::Arena* arena) const {
  Item* n = new Item;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Item::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Item)
  if (_has_bits_[0 / 32] & 127u) {
    if (has_ref()) {
      if (ref_ != NULL) ref_->::aapt::pb::Reference::Clear();
    }
    if (has_str()) {
      if (str_ != NULL) str_->::aapt::pb::String::Clear();
    }
    if (has_raw_str()) {
      if (raw_str_ != NULL) raw_str_->::aapt::pb::RawString::Clear();
    }
    if (has_styled_str()) {
      if (styled_str_ != NULL) styled_str_->::aapt::pb::StyledString::Clear();
    }
    if (has_file()) {
      if (file_ != NULL) file_->::aapt::pb::FileReference::Clear();
    }
    if (has_id()) {
      if (id_ != NULL) id_->::aapt::pb::Id::Clear();
    }
    if (has_prim()) {
      if (prim_ != NULL) prim_->::aapt::pb::Primitive::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Item::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForItem, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Item)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Reference ref = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_str;
        break;
      }

      // optional .aapt.pb.String str = 2;
      case 2: {
        if (tag == 18) {
         parse_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_str()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_raw_str;
        break;
      }

      // optional .aapt.pb.RawString raw_str = 3;
      case 3: {
        if (tag == 26) {
         parse_raw_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_raw_str()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_styled_str;
        break;
      }

      // optional .aapt.pb.StyledString styled_str = 4;
      case 4: {
        if (tag == 34) {
         parse_styled_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_styled_str()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_file;
        break;
      }

      // optional .aapt.pb.FileReference file = 5;
      case 5: {
        if (tag == 42) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_id;
        break;
      }

      // optional .aapt.pb.Id id = 6;
      case 6: {
        if (tag == 50) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_prim;
        break;
      }

      // optional .aapt.pb.Primitive prim = 7;
      case 7: {
        if (tag == 58) {
         parse_prim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_prim()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Item)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Item)
  return false;
#undef DO_
}

void Item::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Item)
  // optional .aapt.pb.Reference ref = 1;
  if (has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->ref_, output);
  }

  // optional .aapt.pb.String str = 2;
  if (has_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->str_, output);
  }

  // optional .aapt.pb.RawString raw_str = 3;
  if (has_raw_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->raw_str_, output);
  }

  // optional .aapt.pb.StyledString styled_str = 4;
  if (has_styled_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->styled_str_, output);
  }

  // optional .aapt.pb.FileReference file = 5;
  if (has_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->file_, output);
  }

  // optional .aapt.pb.Id id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->id_, output);
  }

  // optional .aapt.pb.Primitive prim = 7;
  if (has_prim()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->prim_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Item)
}

int Item::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Item)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional .aapt.pb.Reference ref = 1;
    if (has_ref()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ref_);
    }

    // optional .aapt.pb.String str = 2;
    if (has_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->str_);
    }

    // optional .aapt.pb.RawString raw_str = 3;
    if (has_raw_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->raw_str_);
    }

    // optional .aapt.pb.StyledString styled_str = 4;
    if (has_styled_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->styled_str_);
    }

    // optional .aapt.pb.FileReference file = 5;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->file_);
    }

    // optional .aapt.pb.Id id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional .aapt.pb.Primitive prim = 7;
    if (has_prim()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->prim_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Item::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Item*>(&from));
}

void Item::MergeFrom(const Item& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Item)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ref()) {
      mutable_ref()->::aapt::pb::Reference::MergeFrom(from.ref());
    }
    if (from.has_str()) {
      mutable_str()->::aapt::pb::String::MergeFrom(from.str());
    }
    if (from.has_raw_str()) {
      mutable_raw_str()->::aapt::pb::RawString::MergeFrom(from.raw_str());
    }
    if (from.has_styled_str()) {
      mutable_styled_str()->::aapt::pb::StyledString::MergeFrom(from.styled_str());
    }
    if (from.has_file()) {
      mutable_file()->::aapt::pb::FileReference::MergeFrom(from.file());
    }
    if (from.has_id()) {
      mutable_id()->::aapt::pb::Id::MergeFrom(from.id());
    }
    if (from.has_prim()) {
      mutable_prim()->::aapt::pb::Primitive::MergeFrom(from.prim());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Item::CopyFrom(const Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {

  return true;
}

void Item::Swap(Item* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Item::InternalSwap(Item* other) {
  std::swap(ref_, other->ref_);
  std::swap(str_, other->str_);
  std::swap(raw_str_, other->raw_str_);
  std::swap(styled_str_, other->styled_str_);
  std::swap(file_, other->file_);
  std::swap(id_, other->id_);
  std::swap(prim_, other->prim_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Item::GetTypeName() const {
  return "aapt.pb.Item";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Item

// optional .aapt.pb.Reference ref = 1;
bool Item::has_ref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Item::set_has_ref() {
  _has_bits_[0] |= 0x00000001u;
}
void Item::clear_has_ref() {
  _has_bits_[0] &= ~0x00000001u;
}
void Item::clear_ref() {
  if (ref_ != NULL) ref_->::aapt::pb::Reference::Clear();
  clear_has_ref();
}
const ::aapt::pb::Reference& Item::ref() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.ref)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ref_ != NULL ? *ref_ : *default_instance().ref_;
#else
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
#endif
}
::aapt::pb::Reference* Item::mutable_ref() {
  set_has_ref();
  if (ref_ == NULL) {
    ref_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.ref)
  return ref_;
}
::aapt::pb::Reference* Item::release_ref() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.ref)
  clear_has_ref();
  ::aapt::pb::Reference* temp = ref_;
  ref_ = NULL;
  return temp;
}
void Item::set_allocated_ref(::aapt::pb::Reference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    set_has_ref();
  } else {
    clear_has_ref();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.ref)
}

// optional .aapt.pb.String str = 2;
bool Item::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Item::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
void Item::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
void Item::clear_str() {
  if (str_ != NULL) str_->::aapt::pb::String::Clear();
  clear_has_str();
}
const ::aapt::pb::String& Item::str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return str_ != NULL ? *str_ : *default_instance().str_;
#else
  return str_ != NULL ? *str_ : *default_instance_->str_;
#endif
}
::aapt::pb::String* Item::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::aapt::pb::String;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.str)
  return str_;
}
::aapt::pb::String* Item::release_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.str)
  clear_has_str();
  ::aapt::pb::String* temp = str_;
  str_ = NULL;
  return temp;
}
void Item::set_allocated_str(::aapt::pb::String* str) {
  delete str_;
  str_ = str;
  if (str) {
    set_has_str();
  } else {
    clear_has_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.str)
}

// optional .aapt.pb.RawString raw_str = 3;
bool Item::has_raw_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Item::set_has_raw_str() {
  _has_bits_[0] |= 0x00000004u;
}
void Item::clear_has_raw_str() {
  _has_bits_[0] &= ~0x00000004u;
}
void Item::clear_raw_str() {
  if (raw_str_ != NULL) raw_str_->::aapt::pb::RawString::Clear();
  clear_has_raw_str();
}
const ::aapt::pb::RawString& Item::raw_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.raw_str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return raw_str_ != NULL ? *raw_str_ : *default_instance().raw_str_;
#else
  return raw_str_ != NULL ? *raw_str_ : *default_instance_->raw_str_;
#endif
}
::aapt::pb::RawString* Item::mutable_raw_str() {
  set_has_raw_str();
  if (raw_str_ == NULL) {
    raw_str_ = new ::aapt::pb::RawString;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.raw_str)
  return raw_str_;
}
::aapt::pb::RawString* Item::release_raw_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.raw_str)
  clear_has_raw_str();
  ::aapt::pb::RawString* temp = raw_str_;
  raw_str_ = NULL;
  return temp;
}
void Item::set_allocated_raw_str(::aapt::pb::RawString* raw_str) {
  delete raw_str_;
  raw_str_ = raw_str;
  if (raw_str) {
    set_has_raw_str();
  } else {
    clear_has_raw_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.raw_str)
}

// optional .aapt.pb.StyledString styled_str = 4;
bool Item::has_styled_str() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Item::set_has_styled_str() {
  _has_bits_[0] |= 0x00000008u;
}
void Item::clear_has_styled_str() {
  _has_bits_[0] &= ~0x00000008u;
}
void Item::clear_styled_str() {
  if (styled_str_ != NULL) styled_str_->::aapt::pb::StyledString::Clear();
  clear_has_styled_str();
}
const ::aapt::pb::StyledString& Item::styled_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.styled_str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return styled_str_ != NULL ? *styled_str_ : *default_instance().styled_str_;
#else
  return styled_str_ != NULL ? *styled_str_ : *default_instance_->styled_str_;
#endif
}
::aapt::pb::StyledString* Item::mutable_styled_str() {
  set_has_styled_str();
  if (styled_str_ == NULL) {
    styled_str_ = new ::aapt::pb::StyledString;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.styled_str)
  return styled_str_;
}
::aapt::pb::StyledString* Item::release_styled_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.styled_str)
  clear_has_styled_str();
  ::aapt::pb::StyledString* temp = styled_str_;
  styled_str_ = NULL;
  return temp;
}
void Item::set_allocated_styled_str(::aapt::pb::StyledString* styled_str) {
  delete styled_str_;
  styled_str_ = styled_str;
  if (styled_str) {
    set_has_styled_str();
  } else {
    clear_has_styled_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.styled_str)
}

// optional .aapt.pb.FileReference file = 5;
bool Item::has_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Item::set_has_file() {
  _has_bits_[0] |= 0x00000010u;
}
void Item::clear_has_file() {
  _has_bits_[0] &= ~0x00000010u;
}
void Item::clear_file() {
  if (file_ != NULL) file_->::aapt::pb::FileReference::Clear();
  clear_has_file();
}
const ::aapt::pb::FileReference& Item::file() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.file)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return file_ != NULL ? *file_ : *default_instance().file_;
#else
  return file_ != NULL ? *file_ : *default_instance_->file_;
#endif
}
::aapt::pb::FileReference* Item::mutable_file() {
  set_has_file();
  if (file_ == NULL) {
    file_ = new ::aapt::pb::FileReference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.file)
  return file_;
}
::aapt::pb::FileReference* Item::release_file() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.file)
  clear_has_file();
  ::aapt::pb::FileReference* temp = file_;
  file_ = NULL;
  return temp;
}
void Item::set_allocated_file(::aapt::pb::FileReference* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.file)
}

// optional .aapt.pb.Id id = 6;
bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Item::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void Item::clear_id() {
  if (id_ != NULL) id_->::aapt::pb::Id::Clear();
  clear_has_id();
}
const ::aapt::pb::Id& Item::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
::aapt::pb::Id* Item::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::aapt::pb::Id;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.id)
  return id_;
}
::aapt::pb::Id* Item::release_id() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.id)
  clear_has_id();
  ::aapt::pb::Id* temp = id_;
  id_ = NULL;
  return temp;
}
void Item::set_allocated_id(::aapt::pb::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.id)
}

// optional .aapt.pb.Primitive prim = 7;
bool Item::has_prim() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Item::set_has_prim() {
  _has_bits_[0] |= 0x00000040u;
}
void Item::clear_has_prim() {
  _has_bits_[0] &= ~0x00000040u;
}
void Item::clear_prim() {
  if (prim_ != NULL) prim_->::aapt::pb::Primitive::Clear();
  clear_has_prim();
}
const ::aapt::pb::Primitive& Item::prim() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.prim)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return prim_ != NULL ? *prim_ : *default_instance().prim_;
#else
  return prim_ != NULL ? *prim_ : *default_instance_->prim_;
#endif
}
::aapt::pb::Primitive* Item::mutable_prim() {
  set_has_prim();
  if (prim_ == NULL) {
    prim_ = new ::aapt::pb::Primitive;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.prim)
  return prim_;
}
::aapt::pb::Primitive* Item::release_prim() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.prim)
  clear_has_prim();
  ::aapt::pb::Primitive* temp = prim_;
  prim_ = NULL;
  return temp;
}
void Item::set_allocated_prim(::aapt::pb::Primitive* prim) {
  delete prim_;
  prim_ = prim;
  if (prim) {
    set_has_prim();
  } else {
    clear_has_prim();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.prim)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForCompoundValue(
    CompoundValue* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CompoundValue::kAttrFieldNumber;
const int CompoundValue::kStyleFieldNumber;
const int CompoundValue::kStyleableFieldNumber;
const int CompoundValue::kArrayFieldNumber;
const int CompoundValue::kPluralFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CompoundValue::CompoundValue()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.CompoundValue)
}

void CompoundValue::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attr_ = const_cast< ::aapt::pb::Attribute*>(
      ::aapt::pb::Attribute::internal_default_instance());
#else
  attr_ = const_cast< ::aapt::pb::Attribute*>(&::aapt::pb::Attribute::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  style_ = const_cast< ::aapt::pb::Style*>(
      ::aapt::pb::Style::internal_default_instance());
#else
  style_ = const_cast< ::aapt::pb::Style*>(&::aapt::pb::Style::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  styleable_ = const_cast< ::aapt::pb::Styleable*>(
      ::aapt::pb::Styleable::internal_default_instance());
#else
  styleable_ = const_cast< ::aapt::pb::Styleable*>(&::aapt::pb::Styleable::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  array_ = const_cast< ::aapt::pb::Array*>(
      ::aapt::pb::Array::internal_default_instance());
#else
  array_ = const_cast< ::aapt::pb::Array*>(&::aapt::pb::Array::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  plural_ = const_cast< ::aapt::pb::Plural*>(
      ::aapt::pb::Plural::internal_default_instance());
#else
  plural_ = const_cast< ::aapt::pb::Plural*>(&::aapt::pb::Plural::default_instance());
#endif
}

CompoundValue::CompoundValue(const CompoundValue& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.CompoundValue)
}

void CompoundValue::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attr_ = NULL;
  style_ = NULL;
  styleable_ = NULL;
  array_ = NULL;
  plural_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CompoundValue::~CompoundValue() {
  // @@protoc_insertion_point(destructor:aapt.pb.CompoundValue)
  SharedDtor();
}

void CompoundValue::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete attr_;
    delete style_;
    delete styleable_;
    delete array_;
    delete plural_;
  }
}

void CompoundValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CompoundValue& CompoundValue::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

CompoundValue* CompoundValue::default_instance_ = NULL;

CompoundValue* CompoundValue::New(::google::protobuf::Arena* arena) const {
  CompoundValue* n = new CompoundValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CompoundValue::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.CompoundValue)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_attr()) {
      if (attr_ != NULL) attr_->::aapt::pb::Attribute::Clear();
    }
    if (has_style()) {
      if (style_ != NULL) style_->::aapt::pb::Style::Clear();
    }
    if (has_styleable()) {
      if (styleable_ != NULL) styleable_->::aapt::pb::Styleable::Clear();
    }
    if (has_array()) {
      if (array_ != NULL) array_->::aapt::pb::Array::Clear();
    }
    if (has_plural()) {
      if (plural_ != NULL) plural_->::aapt::pb::Plural::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CompoundValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForCompoundValue, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.CompoundValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Attribute attr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_style;
        break;
      }

      // optional .aapt.pb.Style style = 2;
      case 2: {
        if (tag == 18) {
         parse_style:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_style()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_styleable;
        break;
      }

      // optional .aapt.pb.Styleable styleable = 3;
      case 3: {
        if (tag == 26) {
         parse_styleable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_styleable()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_array;
        break;
      }

      // optional .aapt.pb.Array array = 4;
      case 4: {
        if (tag == 34) {
         parse_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_array()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_plural;
        break;
      }

      // optional .aapt.pb.Plural plural = 5;
      case 5: {
        if (tag == 42) {
         parse_plural:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_plural()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.CompoundValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.CompoundValue)
  return false;
#undef DO_
}

void CompoundValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.CompoundValue)
  // optional .aapt.pb.Attribute attr = 1;
  if (has_attr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->attr_, output);
  }

  // optional .aapt.pb.Style style = 2;
  if (has_style()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->style_, output);
  }

  // optional .aapt.pb.Styleable styleable = 3;
  if (has_styleable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->styleable_, output);
  }

  // optional .aapt.pb.Array array = 4;
  if (has_array()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->array_, output);
  }

  // optional .aapt.pb.Plural plural = 5;
  if (has_plural()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->plural_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.CompoundValue)
}

int CompoundValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.CompoundValue)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .aapt.pb.Attribute attr = 1;
    if (has_attr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->attr_);
    }

    // optional .aapt.pb.Style style = 2;
    if (has_style()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->style_);
    }

    // optional .aapt.pb.Styleable styleable = 3;
    if (has_styleable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->styleable_);
    }

    // optional .aapt.pb.Array array = 4;
    if (has_array()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->array_);
    }

    // optional .aapt.pb.Plural plural = 5;
    if (has_plural()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->plural_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompoundValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CompoundValue*>(&from));
}

void CompoundValue::MergeFrom(const CompoundValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.CompoundValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attr()) {
      mutable_attr()->::aapt::pb::Attribute::MergeFrom(from.attr());
    }
    if (from.has_style()) {
      mutable_style()->::aapt::pb::Style::MergeFrom(from.style());
    }
    if (from.has_styleable()) {
      mutable_styleable()->::aapt::pb::Styleable::MergeFrom(from.styleable());
    }
    if (from.has_array()) {
      mutable_array()->::aapt::pb::Array::MergeFrom(from.array());
    }
    if (from.has_plural()) {
      mutable_plural()->::aapt::pb::Plural::MergeFrom(from.plural());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CompoundValue::CopyFrom(const CompoundValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.CompoundValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompoundValue::IsInitialized() const {

  return true;
}

void CompoundValue::Swap(CompoundValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CompoundValue::InternalSwap(CompoundValue* other) {
  std::swap(attr_, other->attr_);
  std::swap(style_, other->style_);
  std::swap(styleable_, other->styleable_);
  std::swap(array_, other->array_);
  std::swap(plural_, other->plural_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CompoundValue::GetTypeName() const {
  return "aapt.pb.CompoundValue";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CompoundValue

// optional .aapt.pb.Attribute attr = 1;
bool CompoundValue::has_attr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CompoundValue::set_has_attr() {
  _has_bits_[0] |= 0x00000001u;
}
void CompoundValue::clear_has_attr() {
  _has_bits_[0] &= ~0x00000001u;
}
void CompoundValue::clear_attr() {
  if (attr_ != NULL) attr_->::aapt::pb::Attribute::Clear();
  clear_has_attr();
}
const ::aapt::pb::Attribute& CompoundValue::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.attr)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_ != NULL ? *attr_ : *default_instance().attr_;
#else
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
#endif
}
::aapt::pb::Attribute* CompoundValue::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) {
    attr_ = new ::aapt::pb::Attribute;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.attr)
  return attr_;
}
::aapt::pb::Attribute* CompoundValue::release_attr() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.attr)
  clear_has_attr();
  ::aapt::pb::Attribute* temp = attr_;
  attr_ = NULL;
  return temp;
}
void CompoundValue::set_allocated_attr(::aapt::pb::Attribute* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.attr)
}

// optional .aapt.pb.Style style = 2;
bool CompoundValue::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CompoundValue::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
void CompoundValue::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
void CompoundValue::clear_style() {
  if (style_ != NULL) style_->::aapt::pb::Style::Clear();
  clear_has_style();
}
const ::aapt::pb::Style& CompoundValue::style() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.style)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return style_ != NULL ? *style_ : *default_instance().style_;
#else
  return style_ != NULL ? *style_ : *default_instance_->style_;
#endif
}
::aapt::pb::Style* CompoundValue::mutable_style() {
  set_has_style();
  if (style_ == NULL) {
    style_ = new ::aapt::pb::Style;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.style)
  return style_;
}
::aapt::pb::Style* CompoundValue::release_style() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.style)
  clear_has_style();
  ::aapt::pb::Style* temp = style_;
  style_ = NULL;
  return temp;
}
void CompoundValue::set_allocated_style(::aapt::pb::Style* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.style)
}

// optional .aapt.pb.Styleable styleable = 3;
bool CompoundValue::has_styleable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CompoundValue::set_has_styleable() {
  _has_bits_[0] |= 0x00000004u;
}
void CompoundValue::clear_has_styleable() {
  _has_bits_[0] &= ~0x00000004u;
}
void CompoundValue::clear_styleable() {
  if (styleable_ != NULL) styleable_->::aapt::pb::Styleable::Clear();
  clear_has_styleable();
}
const ::aapt::pb::Styleable& CompoundValue::styleable() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.styleable)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return styleable_ != NULL ? *styleable_ : *default_instance().styleable_;
#else
  return styleable_ != NULL ? *styleable_ : *default_instance_->styleable_;
#endif
}
::aapt::pb::Styleable* CompoundValue::mutable_styleable() {
  set_has_styleable();
  if (styleable_ == NULL) {
    styleable_ = new ::aapt::pb::Styleable;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.styleable)
  return styleable_;
}
::aapt::pb::Styleable* CompoundValue::release_styleable() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.styleable)
  clear_has_styleable();
  ::aapt::pb::Styleable* temp = styleable_;
  styleable_ = NULL;
  return temp;
}
void CompoundValue::set_allocated_styleable(::aapt::pb::Styleable* styleable) {
  delete styleable_;
  styleable_ = styleable;
  if (styleable) {
    set_has_styleable();
  } else {
    clear_has_styleable();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.styleable)
}

// optional .aapt.pb.Array array = 4;
bool CompoundValue::has_array() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CompoundValue::set_has_array() {
  _has_bits_[0] |= 0x00000008u;
}
void CompoundValue::clear_has_array() {
  _has_bits_[0] &= ~0x00000008u;
}
void CompoundValue::clear_array() {
  if (array_ != NULL) array_->::aapt::pb::Array::Clear();
  clear_has_array();
}
const ::aapt::pb::Array& CompoundValue::array() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.array)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return array_ != NULL ? *array_ : *default_instance().array_;
#else
  return array_ != NULL ? *array_ : *default_instance_->array_;
#endif
}
::aapt::pb::Array* CompoundValue::mutable_array() {
  set_has_array();
  if (array_ == NULL) {
    array_ = new ::aapt::pb::Array;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.array)
  return array_;
}
::aapt::pb::Array* CompoundValue::release_array() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.array)
  clear_has_array();
  ::aapt::pb::Array* temp = array_;
  array_ = NULL;
  return temp;
}
void CompoundValue::set_allocated_array(::aapt::pb::Array* array) {
  delete array_;
  array_ = array;
  if (array) {
    set_has_array();
  } else {
    clear_has_array();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.array)
}

// optional .aapt.pb.Plural plural = 5;
bool CompoundValue::has_plural() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CompoundValue::set_has_plural() {
  _has_bits_[0] |= 0x00000010u;
}
void CompoundValue::clear_has_plural() {
  _has_bits_[0] &= ~0x00000010u;
}
void CompoundValue::clear_plural() {
  if (plural_ != NULL) plural_->::aapt::pb::Plural::Clear();
  clear_has_plural();
}
const ::aapt::pb::Plural& CompoundValue::plural() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.plural)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return plural_ != NULL ? *plural_ : *default_instance().plural_;
#else
  return plural_ != NULL ? *plural_ : *default_instance_->plural_;
#endif
}
::aapt::pb::Plural* CompoundValue::mutable_plural() {
  set_has_plural();
  if (plural_ == NULL) {
    plural_ = new ::aapt::pb::Plural;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.plural)
  return plural_;
}
::aapt::pb::Plural* CompoundValue::release_plural() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.plural)
  clear_has_plural();
  ::aapt::pb::Plural* temp = plural_;
  plural_ = NULL;
  return temp;
}
void CompoundValue::set_allocated_plural(::aapt::pb::Plural* plural) {
  delete plural_;
  plural_ = plural;
  if (plural) {
    set_has_plural();
  } else {
    clear_has_plural();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.plural)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForReference(
    Reference* ptr) {
  return ptr->mutable_unknown_fields();
}

bool Reference_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Reference_Type Reference::REFERENCE;
const Reference_Type Reference::ATTRIBUTE;
const Reference_Type Reference::Type_MIN;
const Reference_Type Reference::Type_MAX;
const int Reference::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Reference::kTypeFieldNumber;
const int Reference::kIdFieldNumber;
const int Reference::kNameFieldNumber;
const int Reference::kPrivateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Reference::Reference()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Reference)
}

void Reference::InitAsDefaultInstance() {
}

Reference::Reference(const Reference& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Reference)
}

void Reference::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  id_ = 0u;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  private__ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reference::~Reference() {
  // @@protoc_insertion_point(destructor:aapt.pb.Reference)
  SharedDtor();
}

void Reference::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Reference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Reference& Reference::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Reference* Reference::default_instance_ = NULL;

Reference* Reference::New(::google::protobuf::Arena* arena) const {
  Reference* n = new Reference;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Reference::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Reference)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Reference, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Reference*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(type_, id_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    private__ = false;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Reference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForReference, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Reference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Reference.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aapt::pb::Reference_Type_IsValid(value)) {
            set_type(static_cast< ::aapt::pb::Reference_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional uint32 id = 2;
      case 2: {
        if (tag == 16) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_private;
        break;
      }

      // optional bool private = 4;
      case 4: {
        if (tag == 32) {
         parse_private:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &private__)));
          set_has_private_();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Reference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Reference)
  return false;
#undef DO_
}

void Reference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Reference)
  // optional .aapt.pb.Reference.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional bool private = 4;
  if (has_private_()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->private_(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Reference)
}

int Reference::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Reference)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .aapt.pb.Reference.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bool private = 4;
    if (has_private_()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reference::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Reference*>(&from));
}

void Reference::MergeFrom(const Reference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Reference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_private_()) {
      set_private_(from.private_());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Reference::CopyFrom(const Reference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Reference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reference::IsInitialized() const {

  return true;
}

void Reference::Swap(Reference* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Reference::InternalSwap(Reference* other) {
  std::swap(type_, other->type_);
  std::swap(id_, other->id_);
  name_.Swap(&other->name_);
  std::swap(private__, other->private__);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Reference::GetTypeName() const {
  return "aapt.pb.Reference";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Reference

// optional .aapt.pb.Reference.Type type = 1;
bool Reference::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Reference::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Reference::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Reference::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::aapt::pb::Reference_Type Reference::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.type)
  return static_cast< ::aapt::pb::Reference_Type >(type_);
}
 void Reference::set_type(::aapt::pb::Reference_Type value) {
  assert(::aapt::pb::Reference_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.type)
}

// optional uint32 id = 2;
bool Reference::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Reference::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Reference::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Reference::clear_id() {
  id_ = 0u;
  clear_has_id();
}
 ::google::protobuf::uint32 Reference::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.id)
  return id_;
}
 void Reference::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.id)
}

// optional string name = 3;
bool Reference::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Reference::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
void Reference::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void Reference::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Reference::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Reference::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.name)
}
 void Reference::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Reference.name)
}
 void Reference::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Reference.name)
}
 ::std::string* Reference::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Reference.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Reference::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Reference.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Reference::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Reference.name)
}

// optional bool private = 4;
bool Reference::has_private_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Reference::set_has_private_() {
  _has_bits_[0] |= 0x00000008u;
}
void Reference::clear_has_private_() {
  _has_bits_[0] &= ~0x00000008u;
}
void Reference::clear_private_() {
  private__ = false;
  clear_has_private_();
}
 bool Reference::private_() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.private)
  return private__;
}
 void Reference::set_private_(bool value) {
  set_has_private_();
  private__ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.private)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForId(
    Id* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Id::Id()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Id)
}

void Id::InitAsDefaultInstance() {
}

Id::Id(const Id& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Id)
}

void Id::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Id::~Id() {
  // @@protoc_insertion_point(destructor:aapt.pb.Id)
  SharedDtor();
}

void Id::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Id::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Id& Id::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Id* Id::default_instance_ = NULL;

Id* Id::New(::google::protobuf::Arena* arena) const {
  Id* n = new Id;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Id::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Id)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Id::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForId, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Id)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Id)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Id)
  return false;
#undef DO_
}

void Id::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Id)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Id)
}

int Id::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Id)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Id::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Id*>(&from));
}

void Id::MergeFrom(const Id& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Id)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Id::CopyFrom(const Id& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Id)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Id::IsInitialized() const {

  return true;
}

void Id::Swap(Id* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Id::InternalSwap(Id* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Id::GetTypeName() const {
  return "aapt.pb.Id";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Id

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForString(
    String* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int String::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

String::String()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.String)
}

void String::InitAsDefaultInstance() {
}

String::String(const String& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.String)
}

void String::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

String::~String() {
  // @@protoc_insertion_point(destructor:aapt.pb.String)
  SharedDtor();
}

void String::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void String::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const String& String::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

String* String::default_instance_ = NULL;

String* String::New(::google::protobuf::Arena* arena) const {
  String* n = new String;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void String::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.String)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool String::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForString, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.String)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.String)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.String)
  return false;
#undef DO_
}

void String::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.String)
  // optional string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.String)
}

int String::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.String)
  int total_size = 0;

  // optional string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void String::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const String*>(&from));
}

void String::MergeFrom(const String& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.String)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void String::CopyFrom(const String& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.String)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool String::IsInitialized() const {

  return true;
}

void String::Swap(String* other) {
  if (other == this) return;
  InternalSwap(other);
}
void String::InternalSwap(String* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string String::GetTypeName() const {
  return "aapt.pb.String";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// String

// optional string value = 1;
bool String::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void String::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void String::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void String::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& String::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.String.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void String::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.String.value)
}
 void String::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.String.value)
}
 void String::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.String.value)
}
 ::std::string* String::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.String.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* String::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.String.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void String::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.String.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRawString(
    RawString* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RawString::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RawString::RawString()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.RawString)
}

void RawString::InitAsDefaultInstance() {
}

RawString::RawString(const RawString& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.RawString)
}

void RawString::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawString::~RawString() {
  // @@protoc_insertion_point(destructor:aapt.pb.RawString)
  SharedDtor();
}

void RawString::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RawString::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RawString& RawString::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

RawString* RawString::default_instance_ = NULL;

RawString* RawString::New(::google::protobuf::Arena* arena) const {
  RawString* n = new RawString;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RawString::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.RawString)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RawString::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForRawString, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.RawString)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.RawString)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.RawString)
  return false;
#undef DO_
}

void RawString::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.RawString)
  // optional string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.RawString)
}

int RawString::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.RawString)
  int total_size = 0;

  // optional string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawString::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RawString*>(&from));
}

void RawString::MergeFrom(const RawString& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.RawString)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void RawString::CopyFrom(const RawString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.RawString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawString::IsInitialized() const {

  return true;
}

void RawString::Swap(RawString* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RawString::InternalSwap(RawString* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RawString::GetTypeName() const {
  return "aapt.pb.RawString";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RawString

// optional string value = 1;
bool RawString::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RawString::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void RawString::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void RawString::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& RawString::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.RawString.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RawString::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.RawString.value)
}
 void RawString::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.RawString.value)
}
 void RawString::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.RawString.value)
}
 ::std::string* RawString::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.RawString.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RawString::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.RawString.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RawString::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.RawString.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStyledString(
    StyledString* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForStyledString_Span(
    StyledString_Span* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StyledString_Span::kTagFieldNumber;
const int StyledString_Span::kFirstCharFieldNumber;
const int StyledString_Span::kLastCharFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StyledString_Span::StyledString_Span()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.StyledString.Span)
}

void StyledString_Span::InitAsDefaultInstance() {
}

StyledString_Span::StyledString_Span(const StyledString_Span& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.StyledString.Span)
}

void StyledString_Span::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  first_char_ = 0u;
  last_char_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StyledString_Span::~StyledString_Span() {
  // @@protoc_insertion_point(destructor:aapt.pb.StyledString.Span)
  SharedDtor();
}

void StyledString_Span::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StyledString_Span::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StyledString_Span& StyledString_Span::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

StyledString_Span* StyledString_Span::default_instance_ = NULL;

StyledString_Span* StyledString_Span::New(::google::protobuf::Arena* arena) const {
  StyledString_Span* n = new StyledString_Span;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StyledString_Span::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.StyledString.Span)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(StyledString_Span, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<StyledString_Span*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(first_char_, last_char_);
    if (has_tag()) {
      tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool StyledString_Span::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStyledString_Span, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.StyledString.Span)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string tag = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tag()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_first_char;
        break;
      }

      // optional uint32 first_char = 2;
      case 2: {
        if (tag == 16) {
         parse_first_char:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &first_char_)));
          set_has_first_char();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_last_char;
        break;
      }

      // optional uint32 last_char = 3;
      case 3: {
        if (tag == 24) {
         parse_last_char:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &last_char_)));
          set_has_last_char();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.StyledString.Span)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.StyledString.Span)
  return false;
#undef DO_
}

void StyledString_Span::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.StyledString.Span)
  // optional string tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->tag(), output);
  }

  // optional uint32 first_char = 2;
  if (has_first_char()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->first_char(), output);
  }

  // optional uint32 last_char = 3;
  if (has_last_char()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->last_char(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.StyledString.Span)
}

int StyledString_Span::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StyledString.Span)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tag());
    }

    // optional uint32 first_char = 2;
    if (has_first_char()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->first_char());
    }

    // optional uint32 last_char = 3;
    if (has_last_char()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->last_char());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StyledString_Span::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StyledString_Span*>(&from));
}

void StyledString_Span::MergeFrom(const StyledString_Span& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StyledString.Span)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_has_tag();
      tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tag_);
    }
    if (from.has_first_char()) {
      set_first_char(from.first_char());
    }
    if (from.has_last_char()) {
      set_last_char(from.last_char());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void StyledString_Span::CopyFrom(const StyledString_Span& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StyledString.Span)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyledString_Span::IsInitialized() const {

  return true;
}

void StyledString_Span::Swap(StyledString_Span* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StyledString_Span::InternalSwap(StyledString_Span* other) {
  tag_.Swap(&other->tag_);
  std::swap(first_char_, other->first_char_);
  std::swap(last_char_, other->last_char_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StyledString_Span::GetTypeName() const {
  return "aapt.pb.StyledString.Span";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StyledString::kValueFieldNumber;
const int StyledString::kSpanFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StyledString::StyledString()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.StyledString)
}

void StyledString::InitAsDefaultInstance() {
}

StyledString::StyledString(const StyledString& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.StyledString)
}

void StyledString::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StyledString::~StyledString() {
  // @@protoc_insertion_point(destructor:aapt.pb.StyledString)
  SharedDtor();
}

void StyledString::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StyledString::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StyledString& StyledString::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

StyledString* StyledString::default_instance_ = NULL;

StyledString* StyledString::New(::google::protobuf::Arena* arena) const {
  StyledString* n = new StyledString;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StyledString::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.StyledString)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  span_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool StyledString::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStyledString, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.StyledString)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_span;
        break;
      }

      // repeated .aapt.pb.StyledString.Span span = 2;
      case 2: {
        if (tag == 18) {
         parse_span:
          DO_(input->IncrementRecursionDepth());
         parse_loop_span:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_span()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_span;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.StyledString)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.StyledString)
  return false;
#undef DO_
}

void StyledString::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.StyledString)
  // optional string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  // repeated .aapt.pb.StyledString.Span span = 2;
  for (unsigned int i = 0, n = this->span_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->span(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.StyledString)
}

int StyledString::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.StyledString)
  int total_size = 0;

  // optional string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  // repeated .aapt.pb.StyledString.Span span = 2;
  total_size += 1 * this->span_size();
  for (int i = 0; i < this->span_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->span(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StyledString::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StyledString*>(&from));
}

void StyledString::MergeFrom(const StyledString& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.StyledString)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  span_.MergeFrom(from.span_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void StyledString::CopyFrom(const StyledString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.StyledString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyledString::IsInitialized() const {

  return true;
}

void StyledString::Swap(StyledString* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StyledString::InternalSwap(StyledString* other) {
  value_.Swap(&other->value_);
  span_.UnsafeArenaSwap(&other->span_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StyledString::GetTypeName() const {
  return "aapt.pb.StyledString";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StyledString_Span

// optional string tag = 1;
bool StyledString_Span::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StyledString_Span::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
void StyledString_Span::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
void StyledString_Span::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tag();
}
 const ::std::string& StyledString_Span::tag() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.tag)
  return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StyledString_Span::set_tag(const ::std::string& value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.tag)
}
 void StyledString_Span::set_tag(const char* value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.StyledString.Span.tag)
}
 void StyledString_Span::set_tag(const char* value, size_t size) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StyledString.Span.tag)
}
 ::std::string* StyledString_Span::mutable_tag() {
  set_has_tag();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.Span.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StyledString_Span::release_tag() {
  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.Span.tag)
  clear_has_tag();
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StyledString_Span::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.Span.tag)
}

// optional uint32 first_char = 2;
bool StyledString_Span::has_first_char() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StyledString_Span::set_has_first_char() {
  _has_bits_[0] |= 0x00000002u;
}
void StyledString_Span::clear_has_first_char() {
  _has_bits_[0] &= ~0x00000002u;
}
void StyledString_Span::clear_first_char() {
  first_char_ = 0u;
  clear_has_first_char();
}
 ::google::protobuf::uint32 StyledString_Span::first_char() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.first_char)
  return first_char_;
}
 void StyledString_Span::set_first_char(::google::protobuf::uint32 value) {
  set_has_first_char();
  first_char_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.first_char)
}

// optional uint32 last_char = 3;
bool StyledString_Span::has_last_char() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void StyledString_Span::set_has_last_char() {
  _has_bits_[0] |= 0x00000004u;
}
void StyledString_Span::clear_has_last_char() {
  _has_bits_[0] &= ~0x00000004u;
}
void StyledString_Span::clear_last_char() {
  last_char_ = 0u;
  clear_has_last_char();
}
 ::google::protobuf::uint32 StyledString_Span::last_char() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.last_char)
  return last_char_;
}
 void StyledString_Span::set_last_char(::google::protobuf::uint32 value) {
  set_has_last_char();
  last_char_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.last_char)
}

// -------------------------------------------------------------------

// StyledString

// optional string value = 1;
bool StyledString::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StyledString::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void StyledString::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void StyledString::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& StyledString::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StyledString::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.value)
}
 void StyledString::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.StyledString.value)
}
 void StyledString::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StyledString.value)
}
 ::std::string* StyledString::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StyledString::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StyledString::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.value)
}

// repeated .aapt.pb.StyledString.Span span = 2;
int StyledString::span_size() const {
  return span_.size();
}
void StyledString::clear_span() {
  span_.Clear();
}
const ::aapt::pb::StyledString_Span& StyledString::span(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.span)
  return span_.Get(index);
}
::aapt::pb::StyledString_Span* StyledString::mutable_span(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.span)
  return span_.Mutable(index);
}
::aapt::pb::StyledString_Span* StyledString::add_span() {
  // @@protoc_insertion_point(field_add:aapt.pb.StyledString.span)
  return span_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
StyledString::mutable_span() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.StyledString.span)
  return &span_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
StyledString::span() const {
  // @@protoc_insertion_point(field_list:aapt.pb.StyledString.span)
  return span_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFileReference(
    FileReference* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FileReference::kPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FileReference::FileReference()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.FileReference)
}

void FileReference::InitAsDefaultInstance() {
}

FileReference::FileReference(const FileReference& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.FileReference)
}

void FileReference::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileReference::~FileReference() {
  // @@protoc_insertion_point(destructor:aapt.pb.FileReference)
  SharedDtor();
}

void FileReference::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileReference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileReference& FileReference::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

FileReference* FileReference::default_instance_ = NULL;

FileReference* FileReference::New(::google::protobuf::Arena* arena) const {
  FileReference* n = new FileReference;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FileReference::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.FileReference)
  if (has_path()) {
    path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FileReference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFileReference, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.FileReference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.FileReference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.FileReference)
  return false;
#undef DO_
}

void FileReference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.FileReference)
  // optional string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.FileReference)
}

int FileReference::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.FileReference)
  int total_size = 0;

  // optional string path = 1;
  if (has_path()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->path());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileReference::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileReference*>(&from));
}

void FileReference::MergeFrom(const FileReference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.FileReference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_has_path();
      path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FileReference::CopyFrom(const FileReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.FileReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileReference::IsInitialized() const {

  return true;
}

void FileReference::Swap(FileReference* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FileReference::InternalSwap(FileReference* other) {
  path_.Swap(&other->path_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FileReference::GetTypeName() const {
  return "aapt.pb.FileReference";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FileReference

// optional string path = 1;
bool FileReference::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FileReference::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
void FileReference::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
void FileReference::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
 const ::std::string& FileReference::path() const {
  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileReference::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.path)
}
 void FileReference::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.FileReference.path)
}
 void FileReference::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.FileReference.path)
}
 ::std::string* FileReference::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:aapt.pb.FileReference.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileReference::release_path() {
  // @@protoc_insertion_point(field_release:aapt.pb.FileReference.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileReference::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.FileReference.path)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForPrimitive(
    Primitive* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Primitive::kTypeFieldNumber;
const int Primitive::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Primitive::Primitive()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Primitive)
}

void Primitive::InitAsDefaultInstance() {
}

Primitive::Primitive(const Primitive& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Primitive)
}

void Primitive::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0u;
  data_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Primitive::~Primitive() {
  // @@protoc_insertion_point(destructor:aapt.pb.Primitive)
  SharedDtor();
}

void Primitive::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Primitive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Primitive& Primitive::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Primitive* Primitive::default_instance_ = NULL;

Primitive* Primitive::New(::google::protobuf::Arena* arena) const {
  Primitive* n = new Primitive;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Primitive::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Primitive)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Primitive, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Primitive*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, data_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Primitive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPrimitive, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Primitive)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data;
        break;
      }

      // optional uint32 data = 2;
      case 2: {
        if (tag == 16) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_)));
          set_has_data();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Primitive)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Primitive)
  return false;
#undef DO_
}

void Primitive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Primitive)
  // optional uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // optional uint32 data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Primitive)
}

int Primitive::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Primitive)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Primitive::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Primitive*>(&from));
}

void Primitive::MergeFrom(const Primitive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Primitive)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Primitive::CopyFrom(const Primitive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Primitive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Primitive::IsInitialized() const {

  return true;
}

void Primitive::Swap(Primitive* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Primitive::InternalSwap(Primitive* other) {
  std::swap(type_, other->type_);
  std::swap(data_, other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Primitive::GetTypeName() const {
  return "aapt.pb.Primitive";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Primitive

// optional uint32 type = 1;
bool Primitive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Primitive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Primitive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Primitive::clear_type() {
  type_ = 0u;
  clear_has_type();
}
 ::google::protobuf::uint32 Primitive::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.type)
  return type_;
}
 void Primitive::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.type)
}

// optional uint32 data = 2;
bool Primitive::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Primitive::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
void Primitive::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
void Primitive::clear_data() {
  data_ = 0u;
  clear_has_data();
}
 ::google::protobuf::uint32 Primitive::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.data)
  return data_;
}
 void Primitive::set_data(::google::protobuf::uint32 value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForAttribute(
    Attribute* ptr) {
  return ptr->mutable_unknown_fields();
}

bool Attribute_FormatFlags_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 65535:
    case 65536:
    case 131072:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Attribute_FormatFlags Attribute::ANY;
const Attribute_FormatFlags Attribute::REFERENCE;
const Attribute_FormatFlags Attribute::STRING;
const Attribute_FormatFlags Attribute::INTEGER;
const Attribute_FormatFlags Attribute::BOOLEAN;
const Attribute_FormatFlags Attribute::COLOR;
const Attribute_FormatFlags Attribute::FLOAT;
const Attribute_FormatFlags Attribute::DIMENSION;
const Attribute_FormatFlags Attribute::FRACTION;
const Attribute_FormatFlags Attribute::ENUM;
const Attribute_FormatFlags Attribute::FLAGS;
const Attribute_FormatFlags Attribute::FormatFlags_MIN;
const Attribute_FormatFlags Attribute::FormatFlags_MAX;
const int Attribute::FormatFlags_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
static ::std::string* MutableUnknownFieldsForAttribute_Symbol(
    Attribute_Symbol* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Attribute_Symbol::kSourceFieldNumber;
const int Attribute_Symbol::kCommentFieldNumber;
const int Attribute_Symbol::kNameFieldNumber;
const int Attribute_Symbol::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Attribute_Symbol::Attribute_Symbol()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Attribute.Symbol)
}

void Attribute_Symbol::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  name_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  name_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
}

Attribute_Symbol::Attribute_Symbol(const Attribute_Symbol& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Attribute.Symbol)
}

void Attribute_Symbol::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_ = NULL;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attribute_Symbol::~Attribute_Symbol() {
  // @@protoc_insertion_point(destructor:aapt.pb.Attribute.Symbol)
  SharedDtor();
}

void Attribute_Symbol::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete name_;
  }
}

void Attribute_Symbol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Attribute_Symbol& Attribute_Symbol::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Attribute_Symbol* Attribute_Symbol::default_instance_ = NULL;

Attribute_Symbol* Attribute_Symbol::New(::google::protobuf::Arena* arena) const {
  Attribute_Symbol* n = new Attribute_Symbol;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Attribute_Symbol::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Attribute.Symbol)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_name()) {
      if (name_ != NULL) name_->::aapt::pb::Reference::Clear();
    }
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Attribute_Symbol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForAttribute_Symbol, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Attribute.Symbol)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional .aapt.pb.Reference name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_value;
        break;
      }

      // optional uint32 value = 4;
      case 4: {
        if (tag == 32) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Attribute.Symbol)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Attribute.Symbol)
  return false;
#undef DO_
}

void Attribute_Symbol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Attribute.Symbol)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_, output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Reference name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->name_, output);
  }

  // optional uint32 value = 4;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Attribute.Symbol)
}

int Attribute_Symbol::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Attribute.Symbol)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Reference name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->name_);
    }

    // optional uint32 value = 4;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attribute_Symbol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Attribute_Symbol*>(&from));
}

void Attribute_Symbol::MergeFrom(const Attribute_Symbol& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Attribute.Symbol)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_name()) {
      mutable_name()->::aapt::pb::Reference::MergeFrom(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Attribute_Symbol::CopyFrom(const Attribute_Symbol& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Attribute.Symbol)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribute_Symbol::IsInitialized() const {

  return true;
}

void Attribute_Symbol::Swap(Attribute_Symbol* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Attribute_Symbol::InternalSwap(Attribute_Symbol* other) {
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(name_, other->name_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Attribute_Symbol::GetTypeName() const {
  return "aapt.pb.Attribute.Symbol";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Attribute::kFormatFlagsFieldNumber;
const int Attribute::kMinIntFieldNumber;
const int Attribute::kMaxIntFieldNumber;
const int Attribute::kSymbolFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Attribute::Attribute()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Attribute)
}

void Attribute::InitAsDefaultInstance() {
}

Attribute::Attribute(const Attribute& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Attribute)
}

void Attribute::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  format_flags_ = 0u;
  min_int_ = 0;
  max_int_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attribute::~Attribute() {
  // @@protoc_insertion_point(destructor:aapt.pb.Attribute)
  SharedDtor();
}

void Attribute::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Attribute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Attribute& Attribute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Attribute* Attribute::default_instance_ = NULL;

Attribute* Attribute::New(::google::protobuf::Arena* arena) const {
  Attribute* n = new Attribute;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Attribute::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Attribute)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Attribute, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Attribute*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(format_flags_, min_int_);
    max_int_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  symbol_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Attribute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForAttribute, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Attribute)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 format_flags = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &format_flags_)));
          set_has_format_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_min_int;
        break;
      }

      // optional int32 min_int = 2;
      case 2: {
        if (tag == 16) {
         parse_min_int:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_int_)));
          set_has_min_int();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_int;
        break;
      }

      // optional int32 max_int = 3;
      case 3: {
        if (tag == 24) {
         parse_max_int:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_int_)));
          set_has_max_int();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_symbol;
        break;
      }

      // repeated .aapt.pb.Attribute.Symbol symbol = 4;
      case 4: {
        if (tag == 34) {
         parse_symbol:
          DO_(input->IncrementRecursionDepth());
         parse_loop_symbol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_symbol()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_symbol;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Attribute)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Attribute)
  return false;
#undef DO_
}

void Attribute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Attribute)
  // optional uint32 format_flags = 1;
  if (has_format_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->format_flags(), output);
  }

  // optional int32 min_int = 2;
  if (has_min_int()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->min_int(), output);
  }

  // optional int32 max_int = 3;
  if (has_max_int()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->max_int(), output);
  }

  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
  for (unsigned int i = 0, n = this->symbol_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->symbol(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Attribute)
}

int Attribute::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Attribute)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 format_flags = 1;
    if (has_format_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->format_flags());
    }

    // optional int32 min_int = 2;
    if (has_min_int()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min_int());
    }

    // optional int32 max_int = 3;
    if (has_max_int()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_int());
    }

  }
  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
  total_size += 1 * this->symbol_size();
  for (int i = 0; i < this->symbol_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->symbol(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attribute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Attribute*>(&from));
}

void Attribute::MergeFrom(const Attribute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Attribute)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  symbol_.MergeFrom(from.symbol_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_format_flags()) {
      set_format_flags(from.format_flags());
    }
    if (from.has_min_int()) {
      set_min_int(from.min_int());
    }
    if (from.has_max_int()) {
      set_max_int(from.max_int());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Attribute::CopyFrom(const Attribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Attribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribute::IsInitialized() const {

  return true;
}

void Attribute::Swap(Attribute* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Attribute::InternalSwap(Attribute* other) {
  std::swap(format_flags_, other->format_flags_);
  std::swap(min_int_, other->min_int_);
  std::swap(max_int_, other->max_int_);
  symbol_.UnsafeArenaSwap(&other->symbol_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Attribute::GetTypeName() const {
  return "aapt.pb.Attribute";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Attribute_Symbol

// optional .aapt.pb.Source source = 1;
bool Attribute_Symbol::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Attribute_Symbol::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void Attribute_Symbol::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void Attribute_Symbol::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& Attribute_Symbol::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* Attribute_Symbol::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.source)
  return source_;
}
::aapt::pb::Source* Attribute_Symbol::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Attribute_Symbol::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.source)
}

// optional string comment = 2;
bool Attribute_Symbol::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Attribute_Symbol::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
void Attribute_Symbol::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Attribute_Symbol::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& Attribute_Symbol::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Attribute_Symbol::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.comment)
}
 void Attribute_Symbol::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Attribute.Symbol.comment)
}
 void Attribute_Symbol::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Attribute.Symbol.comment)
}
 ::std::string* Attribute_Symbol::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Attribute_Symbol::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Attribute_Symbol::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.comment)
}

// optional .aapt.pb.Reference name = 3;
bool Attribute_Symbol::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Attribute_Symbol::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
void Attribute_Symbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void Attribute_Symbol::clear_name() {
  if (name_ != NULL) name_->::aapt::pb::Reference::Clear();
  clear_has_name();
}
const ::aapt::pb::Reference& Attribute_Symbol::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.name)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return name_ != NULL ? *name_ : *default_instance().name_;
#else
  return name_ != NULL ? *name_ : *default_instance_->name_;
#endif
}
::aapt::pb::Reference* Attribute_Symbol::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    name_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.name)
  return name_;
}
::aapt::pb::Reference* Attribute_Symbol::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.name)
  clear_has_name();
  ::aapt::pb::Reference* temp = name_;
  name_ = NULL;
  return temp;
}
void Attribute_Symbol::set_allocated_name(::aapt::pb::Reference* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.name)
}

// optional uint32 value = 4;
bool Attribute_Symbol::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Attribute_Symbol::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
void Attribute_Symbol::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
void Attribute_Symbol::clear_value() {
  value_ = 0u;
  clear_has_value();
}
 ::google::protobuf::uint32 Attribute_Symbol::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.value)
  return value_;
}
 void Attribute_Symbol::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.value)
}

// -------------------------------------------------------------------

// Attribute

// optional uint32 format_flags = 1;
bool Attribute::has_format_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Attribute::set_has_format_flags() {
  _has_bits_[0] |= 0x00000001u;
}
void Attribute::clear_has_format_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
void Attribute::clear_format_flags() {
  format_flags_ = 0u;
  clear_has_format_flags();
}
 ::google::protobuf::uint32 Attribute::format_flags() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.format_flags)
  return format_flags_;
}
 void Attribute::set_format_flags(::google::protobuf::uint32 value) {
  set_has_format_flags();
  format_flags_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.format_flags)
}

// optional int32 min_int = 2;
bool Attribute::has_min_int() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Attribute::set_has_min_int() {
  _has_bits_[0] |= 0x00000002u;
}
void Attribute::clear_has_min_int() {
  _has_bits_[0] &= ~0x00000002u;
}
void Attribute::clear_min_int() {
  min_int_ = 0;
  clear_has_min_int();
}
 ::google::protobuf::int32 Attribute::min_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.min_int)
  return min_int_;
}
 void Attribute::set_min_int(::google::protobuf::int32 value) {
  set_has_min_int();
  min_int_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.min_int)
}

// optional int32 max_int = 3;
bool Attribute::has_max_int() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Attribute::set_has_max_int() {
  _has_bits_[0] |= 0x00000004u;
}
void Attribute::clear_has_max_int() {
  _has_bits_[0] &= ~0x00000004u;
}
void Attribute::clear_max_int() {
  max_int_ = 0;
  clear_has_max_int();
}
 ::google::protobuf::int32 Attribute::max_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.max_int)
  return max_int_;
}
 void Attribute::set_max_int(::google::protobuf::int32 value) {
  set_has_max_int();
  max_int_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.max_int)
}

// repeated .aapt.pb.Attribute.Symbol symbol = 4;
int Attribute::symbol_size() const {
  return symbol_.size();
}
void Attribute::clear_symbol() {
  symbol_.Clear();
}
const ::aapt::pb::Attribute_Symbol& Attribute::symbol(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.symbol)
  return symbol_.Get(index);
}
::aapt::pb::Attribute_Symbol* Attribute::mutable_symbol(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.symbol)
  return symbol_.Mutable(index);
}
::aapt::pb::Attribute_Symbol* Attribute::add_symbol() {
  // @@protoc_insertion_point(field_add:aapt.pb.Attribute.symbol)
  return symbol_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
Attribute::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Attribute.symbol)
  return &symbol_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
Attribute::symbol() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Attribute.symbol)
  return symbol_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStyle(
    Style* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForStyle_Entry(
    Style_Entry* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Style_Entry::kSourceFieldNumber;
const int Style_Entry::kCommentFieldNumber;
const int Style_Entry::kKeyFieldNumber;
const int Style_Entry::kItemFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Style_Entry::Style_Entry()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Style.Entry)
}

void Style_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  key_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  key_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

Style_Entry::Style_Entry(const Style_Entry& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Style.Entry)
}

void Style_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_ = NULL;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Style_Entry::~Style_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Style.Entry)
  SharedDtor();
}

void Style_Entry::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete key_;
    delete item_;
  }
}

void Style_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Style_Entry& Style_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Style_Entry* Style_Entry::default_instance_ = NULL;

Style_Entry* Style_Entry::New(::google::protobuf::Arena* arena) const {
  Style_Entry* n = new Style_Entry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Style_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Style.Entry)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_key()) {
      if (key_ != NULL) key_->::aapt::pb::Reference::Clear();
    }
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Style_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStyle_Entry, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Style.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_key;
        break;
      }

      // optional .aapt.pb.Reference key = 3;
      case 3: {
        if (tag == 26) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 4;
      case 4: {
        if (tag == 34) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Style.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Style.Entry)
  return false;
#undef DO_
}

void Style_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Style.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_, output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Reference key = 3;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->key_, output);
  }

  // optional .aapt.pb.Item item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->item_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Style.Entry)
}

int Style_Entry::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Style.Entry)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Reference key = 3;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->key_);
    }

    // optional .aapt.pb.Item item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->item_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Style_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Style_Entry*>(&from));
}

void Style_Entry::MergeFrom(const Style_Entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Style.Entry)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_key()) {
      mutable_key()->::aapt::pb::Reference::MergeFrom(from.key());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Style_Entry::CopyFrom(const Style_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Style.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Style_Entry::IsInitialized() const {

  return true;
}

void Style_Entry::Swap(Style_Entry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Style_Entry::InternalSwap(Style_Entry* other) {
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(key_, other->key_);
  std::swap(item_, other->item_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Style_Entry::GetTypeName() const {
  return "aapt.pb.Style.Entry";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Style::kParentFieldNumber;
const int Style::kParentSourceFieldNumber;
const int Style::kEntryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Style::Style()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Style)
}

void Style::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  parent_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  parent_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  parent_source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  parent_source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
}

Style::Style(const Style& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Style)
}

void Style::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_ = NULL;
  parent_source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Style::~Style() {
  // @@protoc_insertion_point(destructor:aapt.pb.Style)
  SharedDtor();
}

void Style::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete parent_;
    delete parent_source_;
  }
}

void Style::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Style& Style::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Style* Style::default_instance_ = NULL;

Style* Style::New(::google::protobuf::Arena* arena) const {
  Style* n = new Style;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Style::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Style)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_parent()) {
      if (parent_ != NULL) parent_->::aapt::pb::Reference::Clear();
    }
    if (has_parent_source()) {
      if (parent_source_ != NULL) parent_source_->::aapt::pb::Source::Clear();
    }
  }
  entry_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Style::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStyle, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Style)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Reference parent = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parent_source;
        break;
      }

      // optional .aapt.pb.Source parent_source = 2;
      case 2: {
        if (tag == 18) {
         parse_parent_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entry;
        break;
      }

      // repeated .aapt.pb.Style.Entry entry = 3;
      case 3: {
        if (tag == 26) {
         parse_entry:
          DO_(input->IncrementRecursionDepth());
         parse_loop_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_entry;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Style)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Style)
  return false;
#undef DO_
}

void Style::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Style)
  // optional .aapt.pb.Reference parent = 1;
  if (has_parent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->parent_, output);
  }

  // optional .aapt.pb.Source parent_source = 2;
  if (has_parent_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->parent_source_, output);
  }

  // repeated .aapt.pb.Style.Entry entry = 3;
  for (unsigned int i = 0, n = this->entry_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->entry(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Style)
}

int Style::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Style)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .aapt.pb.Reference parent = 1;
    if (has_parent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->parent_);
    }

    // optional .aapt.pb.Source parent_source = 2;
    if (has_parent_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->parent_source_);
    }

  }
  // repeated .aapt.pb.Style.Entry entry = 3;
  total_size += 1 * this->entry_size();
  for (int i = 0; i < this->entry_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entry(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Style::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Style*>(&from));
}

void Style::MergeFrom(const Style& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Style)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  entry_.MergeFrom(from.entry_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_parent()) {
      mutable_parent()->::aapt::pb::Reference::MergeFrom(from.parent());
    }
    if (from.has_parent_source()) {
      mutable_parent_source()->::aapt::pb::Source::MergeFrom(from.parent_source());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Style::CopyFrom(const Style& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Style)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Style::IsInitialized() const {

  return true;
}

void Style::Swap(Style* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Style::InternalSwap(Style* other) {
  std::swap(parent_, other->parent_);
  std::swap(parent_source_, other->parent_source_);
  entry_.UnsafeArenaSwap(&other->entry_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Style::GetTypeName() const {
  return "aapt.pb.Style";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Style_Entry

// optional .aapt.pb.Source source = 1;
bool Style_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Style_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void Style_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void Style_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& Style_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* Style_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.source)
  return source_;
}
::aapt::pb::Source* Style_Entry::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Style_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.source)
}

// optional string comment = 2;
bool Style_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Style_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
void Style_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Style_Entry::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& Style_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Style_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Style.Entry.comment)
}
 void Style_Entry::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Style.Entry.comment)
}
 void Style_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Style.Entry.comment)
}
 ::std::string* Style_Entry::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Style_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Style_Entry::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.comment)
}

// optional .aapt.pb.Reference key = 3;
bool Style_Entry::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Style_Entry::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
void Style_Entry::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void Style_Entry::clear_key() {
  if (key_ != NULL) key_->::aapt::pb::Reference::Clear();
  clear_has_key();
}
const ::aapt::pb::Reference& Style_Entry::key() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_ != NULL ? *key_ : *default_instance().key_;
#else
  return key_ != NULL ? *key_ : *default_instance_->key_;
#endif
}
::aapt::pb::Reference* Style_Entry::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.key)
  return key_;
}
::aapt::pb::Reference* Style_Entry::release_key() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.key)
  clear_has_key();
  ::aapt::pb::Reference* temp = key_;
  key_ = NULL;
  return temp;
}
void Style_Entry::set_allocated_key(::aapt::pb::Reference* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.key)
}

// optional .aapt.pb.Item item = 4;
bool Style_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Style_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
void Style_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
void Style_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
const ::aapt::pb::Item& Style_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
::aapt::pb::Item* Style_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.item)
  return item_;
}
::aapt::pb::Item* Style_Entry::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
void Style_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.item)
}

// -------------------------------------------------------------------

// Style

// optional .aapt.pb.Reference parent = 1;
bool Style::has_parent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Style::set_has_parent() {
  _has_bits_[0] |= 0x00000001u;
}
void Style::clear_has_parent() {
  _has_bits_[0] &= ~0x00000001u;
}
void Style::clear_parent() {
  if (parent_ != NULL) parent_->::aapt::pb::Reference::Clear();
  clear_has_parent();
}
const ::aapt::pb::Reference& Style::parent() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parent_ != NULL ? *parent_ : *default_instance().parent_;
#else
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
#endif
}
::aapt::pb::Reference* Style::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) {
    parent_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent)
  return parent_;
}
::aapt::pb::Reference* Style::release_parent() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent)
  clear_has_parent();
  ::aapt::pb::Reference* temp = parent_;
  parent_ = NULL;
  return temp;
}
void Style::set_allocated_parent(::aapt::pb::Reference* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent)
}

// optional .aapt.pb.Source parent_source = 2;
bool Style::has_parent_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Style::set_has_parent_source() {
  _has_bits_[0] |= 0x00000002u;
}
void Style::clear_has_parent_source() {
  _has_bits_[0] &= ~0x00000002u;
}
void Style::clear_parent_source() {
  if (parent_source_ != NULL) parent_source_->::aapt::pb::Source::Clear();
  clear_has_parent_source();
}
const ::aapt::pb::Source& Style::parent_source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent_source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parent_source_ != NULL ? *parent_source_ : *default_instance().parent_source_;
#else
  return parent_source_ != NULL ? *parent_source_ : *default_instance_->parent_source_;
#endif
}
::aapt::pb::Source* Style::mutable_parent_source() {
  set_has_parent_source();
  if (parent_source_ == NULL) {
    parent_source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent_source)
  return parent_source_;
}
::aapt::pb::Source* Style::release_parent_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent_source)
  clear_has_parent_source();
  ::aapt::pb::Source* temp = parent_source_;
  parent_source_ = NULL;
  return temp;
}
void Style::set_allocated_parent_source(::aapt::pb::Source* parent_source) {
  delete parent_source_;
  parent_source_ = parent_source;
  if (parent_source) {
    set_has_parent_source();
  } else {
    clear_has_parent_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent_source)
}

// repeated .aapt.pb.Style.Entry entry = 3;
int Style::entry_size() const {
  return entry_.size();
}
void Style::clear_entry() {
  entry_.Clear();
}
const ::aapt::pb::Style_Entry& Style::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.entry)
  return entry_.Get(index);
}
::aapt::pb::Style_Entry* Style::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.entry)
  return entry_.Mutable(index);
}
::aapt::pb::Style_Entry* Style::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Style.entry)
  return entry_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >*
Style::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Style.entry)
  return &entry_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >&
Style::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Style.entry)
  return entry_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStyleable(
    Styleable* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForStyleable_Entry(
    Styleable_Entry* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Styleable_Entry::kSourceFieldNumber;
const int Styleable_Entry::kCommentFieldNumber;
const int Styleable_Entry::kAttrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Styleable_Entry::Styleable_Entry()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Styleable.Entry)
}

void Styleable_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attr_ = const_cast< ::aapt::pb::Reference*>(
      ::aapt::pb::Reference::internal_default_instance());
#else
  attr_ = const_cast< ::aapt::pb::Reference*>(&::aapt::pb::Reference::default_instance());
#endif
}

Styleable_Entry::Styleable_Entry(const Styleable_Entry& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Styleable.Entry)
}

void Styleable_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attr_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Styleable_Entry::~Styleable_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Styleable.Entry)
  SharedDtor();
}

void Styleable_Entry::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete attr_;
  }
}

void Styleable_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Styleable_Entry& Styleable_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Styleable_Entry* Styleable_Entry::default_instance_ = NULL;

Styleable_Entry* Styleable_Entry::New(::google::protobuf::Arena* arena) const {
  Styleable_Entry* n = new Styleable_Entry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Styleable_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Styleable.Entry)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_attr()) {
      if (attr_ != NULL) attr_->::aapt::pb::Reference::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Styleable_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStyleable_Entry, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Styleable.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_attr;
        break;
      }

      // optional .aapt.pb.Reference attr = 3;
      case 3: {
        if (tag == 26) {
         parse_attr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Styleable.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Styleable.Entry)
  return false;
#undef DO_
}

void Styleable_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Styleable.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_, output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Reference attr = 3;
  if (has_attr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->attr_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Styleable.Entry)
}

int Styleable_Entry::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Styleable.Entry)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Reference attr = 3;
    if (has_attr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->attr_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Styleable_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Styleable_Entry*>(&from));
}

void Styleable_Entry::MergeFrom(const Styleable_Entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Styleable.Entry)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_attr()) {
      mutable_attr()->::aapt::pb::Reference::MergeFrom(from.attr());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Styleable_Entry::CopyFrom(const Styleable_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Styleable.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Styleable_Entry::IsInitialized() const {

  return true;
}

void Styleable_Entry::Swap(Styleable_Entry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Styleable_Entry::InternalSwap(Styleable_Entry* other) {
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(attr_, other->attr_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Styleable_Entry::GetTypeName() const {
  return "aapt.pb.Styleable.Entry";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Styleable::kEntryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Styleable::Styleable()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Styleable)
}

void Styleable::InitAsDefaultInstance() {
}

Styleable::Styleable(const Styleable& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Styleable)
}

void Styleable::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Styleable::~Styleable() {
  // @@protoc_insertion_point(destructor:aapt.pb.Styleable)
  SharedDtor();
}

void Styleable::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Styleable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Styleable& Styleable::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Styleable* Styleable::default_instance_ = NULL;

Styleable* Styleable::New(::google::protobuf::Arena* arena) const {
  Styleable* n = new Styleable;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Styleable::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Styleable)
  entry_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Styleable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStyleable, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Styleable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.Styleable.Entry entry = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_entry;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Styleable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Styleable)
  return false;
#undef DO_
}

void Styleable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Styleable)
  // repeated .aapt.pb.Styleable.Entry entry = 1;
  for (unsigned int i = 0, n = this->entry_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->entry(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Styleable)
}

int Styleable::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Styleable)
  int total_size = 0;

  // repeated .aapt.pb.Styleable.Entry entry = 1;
  total_size += 1 * this->entry_size();
  for (int i = 0; i < this->entry_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entry(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Styleable::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Styleable*>(&from));
}

void Styleable::MergeFrom(const Styleable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Styleable)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  entry_.MergeFrom(from.entry_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Styleable::CopyFrom(const Styleable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Styleable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Styleable::IsInitialized() const {

  return true;
}

void Styleable::Swap(Styleable* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Styleable::InternalSwap(Styleable* other) {
  entry_.UnsafeArenaSwap(&other->entry_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Styleable::GetTypeName() const {
  return "aapt.pb.Styleable";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Styleable_Entry

// optional .aapt.pb.Source source = 1;
bool Styleable_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Styleable_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void Styleable_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void Styleable_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& Styleable_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* Styleable_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.source)
  return source_;
}
::aapt::pb::Source* Styleable_Entry::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Styleable_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.source)
}

// optional string comment = 2;
bool Styleable_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Styleable_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
void Styleable_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Styleable_Entry::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& Styleable_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Styleable_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Styleable.Entry.comment)
}
 void Styleable_Entry::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Styleable.Entry.comment)
}
 void Styleable_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Styleable.Entry.comment)
}
 ::std::string* Styleable_Entry::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Styleable_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Styleable_Entry::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.comment)
}

// optional .aapt.pb.Reference attr = 3;
bool Styleable_Entry::has_attr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Styleable_Entry::set_has_attr() {
  _has_bits_[0] |= 0x00000004u;
}
void Styleable_Entry::clear_has_attr() {
  _has_bits_[0] &= ~0x00000004u;
}
void Styleable_Entry::clear_attr() {
  if (attr_ != NULL) attr_->::aapt::pb::Reference::Clear();
  clear_has_attr();
}
const ::aapt::pb::Reference& Styleable_Entry::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.attr)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_ != NULL ? *attr_ : *default_instance().attr_;
#else
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
#endif
}
::aapt::pb::Reference* Styleable_Entry::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) {
    attr_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.attr)
  return attr_;
}
::aapt::pb::Reference* Styleable_Entry::release_attr() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.attr)
  clear_has_attr();
  ::aapt::pb::Reference* temp = attr_;
  attr_ = NULL;
  return temp;
}
void Styleable_Entry::set_allocated_attr(::aapt::pb::Reference* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.attr)
}

// -------------------------------------------------------------------

// Styleable

// repeated .aapt.pb.Styleable.Entry entry = 1;
int Styleable::entry_size() const {
  return entry_.size();
}
void Styleable::clear_entry() {
  entry_.Clear();
}
const ::aapt::pb::Styleable_Entry& Styleable::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.entry)
  return entry_.Get(index);
}
::aapt::pb::Styleable_Entry* Styleable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.entry)
  return entry_.Mutable(index);
}
::aapt::pb::Styleable_Entry* Styleable::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Styleable.entry)
  return entry_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
Styleable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Styleable.entry)
  return &entry_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
Styleable::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Styleable.entry)
  return entry_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForArray(
    Array* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForArray_Element(
    Array_Element* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Array_Element::kSourceFieldNumber;
const int Array_Element::kCommentFieldNumber;
const int Array_Element::kItemFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Array_Element::Array_Element()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Array.Element)
}

void Array_Element::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

Array_Element::Array_Element(const Array_Element& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Array.Element)
}

void Array_Element::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Array_Element::~Array_Element() {
  // @@protoc_insertion_point(destructor:aapt.pb.Array.Element)
  SharedDtor();
}

void Array_Element::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete item_;
  }
}

void Array_Element::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Array_Element& Array_Element::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Array_Element* Array_Element::default_instance_ = NULL;

Array_Element* Array_Element::New(::google::protobuf::Arena* arena) const {
  Array_Element* n = new Array_Element;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Array_Element::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Array.Element)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Array_Element::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForArray_Element, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Array.Element)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 3;
      case 3: {
        if (tag == 26) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Array.Element)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Array.Element)
  return false;
#undef DO_
}

void Array_Element::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Array.Element)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_, output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Item item = 3;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->item_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Array.Element)
}

int Array_Element::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Array.Element)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Item item = 3;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->item_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Array_Element::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Array_Element*>(&from));
}

void Array_Element::MergeFrom(const Array_Element& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Array.Element)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Array_Element::CopyFrom(const Array_Element& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Array.Element)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Array_Element::IsInitialized() const {

  return true;
}

void Array_Element::Swap(Array_Element* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Array_Element::InternalSwap(Array_Element* other) {
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(item_, other->item_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Array_Element::GetTypeName() const {
  return "aapt.pb.Array.Element";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Array::kElementFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Array::Array()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Array)
}

void Array::InitAsDefaultInstance() {
}

Array::Array(const Array& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Array)
}

void Array::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Array::~Array() {
  // @@protoc_insertion_point(destructor:aapt.pb.Array)
  SharedDtor();
}

void Array::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Array::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Array& Array::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Array* Array::default_instance_ = NULL;

Array* Array::New(::google::protobuf::Arena* arena) const {
  Array* n = new Array;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Array::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Array)
  element_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Array::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForArray, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Array)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.Array.Element element = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_element:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_element()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_element;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Array)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Array)
  return false;
#undef DO_
}

void Array::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Array)
  // repeated .aapt.pb.Array.Element element = 1;
  for (unsigned int i = 0, n = this->element_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->element(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Array)
}

int Array::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Array)
  int total_size = 0;

  // repeated .aapt.pb.Array.Element element = 1;
  total_size += 1 * this->element_size();
  for (int i = 0; i < this->element_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->element(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Array::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Array*>(&from));
}

void Array::MergeFrom(const Array& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Array)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  element_.MergeFrom(from.element_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Array::CopyFrom(const Array& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Array)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Array::IsInitialized() const {

  return true;
}

void Array::Swap(Array* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Array::InternalSwap(Array* other) {
  element_.UnsafeArenaSwap(&other->element_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Array::GetTypeName() const {
  return "aapt.pb.Array";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Array_Element

// optional .aapt.pb.Source source = 1;
bool Array_Element::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Array_Element::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void Array_Element::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void Array_Element::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& Array_Element::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* Array_Element::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.source)
  return source_;
}
::aapt::pb::Source* Array_Element::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Array_Element::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.source)
}

// optional string comment = 2;
bool Array_Element::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Array_Element::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
void Array_Element::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Array_Element::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& Array_Element::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Array_Element::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Array.Element.comment)
}
 void Array_Element::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Array.Element.comment)
}
 void Array_Element::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Array.Element.comment)
}
 ::std::string* Array_Element::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Array_Element::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Array_Element::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.comment)
}

// optional .aapt.pb.Item item = 3;
bool Array_Element::has_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Array_Element::set_has_item() {
  _has_bits_[0] |= 0x00000004u;
}
void Array_Element::clear_has_item() {
  _has_bits_[0] &= ~0x00000004u;
}
void Array_Element::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
const ::aapt::pb::Item& Array_Element::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
::aapt::pb::Item* Array_Element::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.item)
  return item_;
}
::aapt::pb::Item* Array_Element::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
void Array_Element::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.item)
}

// -------------------------------------------------------------------

// Array

// repeated .aapt.pb.Array.Element element = 1;
int Array::element_size() const {
  return element_.size();
}
void Array::clear_element() {
  element_.Clear();
}
const ::aapt::pb::Array_Element& Array::element(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.element)
  return element_.Get(index);
}
::aapt::pb::Array_Element* Array::mutable_element(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.element)
  return element_.Mutable(index);
}
::aapt::pb::Array_Element* Array::add_element() {
  // @@protoc_insertion_point(field_add:aapt.pb.Array.element)
  return element_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element >*
Array::mutable_element() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Array.element)
  return &element_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element >&
Array::element() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Array.element)
  return element_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForPlural(
    Plural* ptr) {
  return ptr->mutable_unknown_fields();
}

bool Plural_Arity_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Plural_Arity Plural::ZERO;
const Plural_Arity Plural::ONE;
const Plural_Arity Plural::TWO;
const Plural_Arity Plural::FEW;
const Plural_Arity Plural::MANY;
const Plural_Arity Plural::OTHER;
const Plural_Arity Plural::Arity_MIN;
const Plural_Arity Plural::Arity_MAX;
const int Plural::Arity_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
static ::std::string* MutableUnknownFieldsForPlural_Entry(
    Plural_Entry* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Plural_Entry::kSourceFieldNumber;
const int Plural_Entry::kCommentFieldNumber;
const int Plural_Entry::kArityFieldNumber;
const int Plural_Entry::kItemFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Plural_Entry::Plural_Entry()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Plural.Entry)
}

void Plural_Entry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::Source*>(
      ::aapt::pb::Source::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::Source*>(&::aapt::pb::Source::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

Plural_Entry::Plural_Entry(const Plural_Entry& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Plural.Entry)
}

void Plural_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  arity_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Plural_Entry::~Plural_Entry() {
  // @@protoc_insertion_point(destructor:aapt.pb.Plural.Entry)
  SharedDtor();
}

void Plural_Entry::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete item_;
  }
}

void Plural_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Plural_Entry& Plural_Entry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Plural_Entry* Plural_Entry::default_instance_ = NULL;

Plural_Entry* Plural_Entry::New(::google::protobuf::Arena* arena) const {
  Plural_Entry* n = new Plural_Entry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Plural_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Plural.Entry)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::Source::Clear();
    }
    if (has_comment()) {
      comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    arity_ = 0;
    if (has_item()) {
      if (item_ != NULL) item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Plural_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPlural_Entry, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Plural.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_comment;
        break;
      }

      // optional string comment = 2;
      case 2: {
        if (tag == 18) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_arity;
        break;
      }

      // optional .aapt.pb.Plural.Arity arity = 3;
      case 3: {
        if (tag == 24) {
         parse_arity:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aapt::pb::Plural_Arity_IsValid(value)) {
            set_arity(static_cast< ::aapt::pb::Plural_Arity >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_item;
        break;
      }

      // optional .aapt.pb.Item item = 4;
      case 4: {
        if (tag == 34) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Plural.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Plural.Entry)
  return false;
#undef DO_
}

void Plural_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Plural.Entry)
  // optional .aapt.pb.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->source_, output);
  }

  // optional string comment = 2;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->comment(), output);
  }

  // optional .aapt.pb.Plural.Arity arity = 3;
  if (has_arity()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->arity(), output);
  }

  // optional .aapt.pb.Item item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->item_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Plural.Entry)
}

int Plural_Entry::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Plural.Entry)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .aapt.pb.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional string comment = 2;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional .aapt.pb.Plural.Arity arity = 3;
    if (has_arity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->arity());
    }

    // optional .aapt.pb.Item item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->item_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plural_Entry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Plural_Entry*>(&from));
}

void Plural_Entry::MergeFrom(const Plural_Entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Plural.Entry)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::aapt::pb::Source::MergeFrom(from.source());
    }
    if (from.has_comment()) {
      set_has_comment();
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
    if (from.has_arity()) {
      set_arity(from.arity());
    }
    if (from.has_item()) {
      mutable_item()->::aapt::pb::Item::MergeFrom(from.item());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Plural_Entry::CopyFrom(const Plural_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Plural.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plural_Entry::IsInitialized() const {

  return true;
}

void Plural_Entry::Swap(Plural_Entry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Plural_Entry::InternalSwap(Plural_Entry* other) {
  std::swap(source_, other->source_);
  comment_.Swap(&other->comment_);
  std::swap(arity_, other->arity_);
  std::swap(item_, other->item_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Plural_Entry::GetTypeName() const {
  return "aapt.pb.Plural.Entry";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Plural::kEntryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Plural::Plural()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.Plural)
}

void Plural::InitAsDefaultInstance() {
}

Plural::Plural(const Plural& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.Plural)
}

void Plural::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Plural::~Plural() {
  // @@protoc_insertion_point(destructor:aapt.pb.Plural)
  SharedDtor();
}

void Plural::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Plural::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Plural& Plural::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

Plural* Plural::default_instance_ = NULL;

Plural* Plural::New(::google::protobuf::Arena* arena) const {
  Plural* n = new Plural;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Plural::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.Plural)
  entry_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Plural::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPlural, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.Plural)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.Plural.Entry entry = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_entry;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.Plural)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.Plural)
  return false;
#undef DO_
}

void Plural::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.Plural)
  // repeated .aapt.pb.Plural.Entry entry = 1;
  for (unsigned int i = 0, n = this->entry_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->entry(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.Plural)
}

int Plural::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.Plural)
  int total_size = 0;

  // repeated .aapt.pb.Plural.Entry entry = 1;
  total_size += 1 * this->entry_size();
  for (int i = 0; i < this->entry_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entry(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plural::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Plural*>(&from));
}

void Plural::MergeFrom(const Plural& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.Plural)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  entry_.MergeFrom(from.entry_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Plural::CopyFrom(const Plural& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.Plural)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plural::IsInitialized() const {

  return true;
}

void Plural::Swap(Plural* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Plural::InternalSwap(Plural* other) {
  entry_.UnsafeArenaSwap(&other->entry_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Plural::GetTypeName() const {
  return "aapt.pb.Plural";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Plural_Entry

// optional .aapt.pb.Source source = 1;
bool Plural_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Plural_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void Plural_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void Plural_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
const ::aapt::pb::Source& Plural_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::Source* Plural_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.source)
  return source_;
}
::aapt::pb::Source* Plural_Entry::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Plural_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.source)
}

// optional string comment = 2;
bool Plural_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Plural_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
void Plural_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Plural_Entry::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
 const ::std::string& Plural_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Plural_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.comment)
}
 void Plural_Entry::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Plural.Entry.comment)
}
 void Plural_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Plural.Entry.comment)
}
 ::std::string* Plural_Entry::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Plural_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Plural_Entry::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.comment)
}

// optional .aapt.pb.Plural.Arity arity = 3;
bool Plural_Entry::has_arity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Plural_Entry::set_has_arity() {
  _has_bits_[0] |= 0x00000004u;
}
void Plural_Entry::clear_has_arity() {
  _has_bits_[0] &= ~0x00000004u;
}
void Plural_Entry::clear_arity() {
  arity_ = 0;
  clear_has_arity();
}
 ::aapt::pb::Plural_Arity Plural_Entry::arity() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.arity)
  return static_cast< ::aapt::pb::Plural_Arity >(arity_);
}
 void Plural_Entry::set_arity(::aapt::pb::Plural_Arity value) {
  assert(::aapt::pb::Plural_Arity_IsValid(value));
  set_has_arity();
  arity_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.arity)
}

// optional .aapt.pb.Item item = 4;
bool Plural_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Plural_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
void Plural_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
void Plural_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
const ::aapt::pb::Item& Plural_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
::aapt::pb::Item* Plural_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.item)
  return item_;
}
::aapt::pb::Item* Plural_Entry::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
void Plural_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.item)
}

// -------------------------------------------------------------------

// Plural

// repeated .aapt.pb.Plural.Entry entry = 1;
int Plural::entry_size() const {
  return entry_.size();
}
void Plural::clear_entry() {
  entry_.Clear();
}
const ::aapt::pb::Plural_Entry& Plural::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.entry)
  return entry_.Get(index);
}
::aapt::pb::Plural_Entry* Plural::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.entry)
  return entry_.Mutable(index);
}
::aapt::pb::Plural_Entry* Plural::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Plural.entry)
  return entry_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
Plural::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Plural.entry)
  return &entry_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
Plural::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Plural.entry)
  return entry_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForXmlNode(
    XmlNode* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int XmlNode::kElementFieldNumber;
const int XmlNode::kTextFieldNumber;
const int XmlNode::kSourceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

XmlNode::XmlNode()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.XmlNode)
}

void XmlNode::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  element_ = const_cast< ::aapt::pb::XmlElement*>(
      ::aapt::pb::XmlElement::internal_default_instance());
#else
  element_ = const_cast< ::aapt::pb::XmlElement*>(&::aapt::pb::XmlElement::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::SourcePosition*>(
      ::aapt::pb::SourcePosition::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::SourcePosition*>(&::aapt::pb::SourcePosition::default_instance());
#endif
}

XmlNode::XmlNode(const XmlNode& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlNode)
}

void XmlNode::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  element_ = NULL;
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XmlNode::~XmlNode() {
  // @@protoc_insertion_point(destructor:aapt.pb.XmlNode)
  SharedDtor();
}

void XmlNode::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete element_;
    delete source_;
  }
}

void XmlNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const XmlNode& XmlNode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

XmlNode* XmlNode::default_instance_ = NULL;

XmlNode* XmlNode::New(::google::protobuf::Arena* arena) const {
  XmlNode* n = new XmlNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void XmlNode::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlNode)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_element()) {
      if (element_ != NULL) element_->::aapt::pb::XmlElement::Clear();
    }
    if (has_text()) {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool XmlNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForXmlNode, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.XmlNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aapt.pb.XmlElement element = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_element()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_text;
        break;
      }

      // optional string text = 2;
      case 2: {
        if (tag == 18) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source;
        break;
      }

      // optional .aapt.pb.SourcePosition source = 3;
      case 3: {
        if (tag == 26) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.XmlNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.XmlNode)
  return false;
#undef DO_
}

void XmlNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.XmlNode)
  // optional .aapt.pb.XmlElement element = 1;
  if (has_element()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->element_, output);
  }

  // optional string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->text(), output);
  }

  // optional .aapt.pb.SourcePosition source = 3;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->source_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.XmlNode)
}

int XmlNode::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlNode)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .aapt.pb.XmlElement element = 1;
    if (has_element()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->element_);
    }

    // optional string text = 2;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional .aapt.pb.SourcePosition source = 3;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XmlNode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const XmlNode*>(&from));
}

void XmlNode::MergeFrom(const XmlNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_element()) {
      mutable_element()->::aapt::pb::XmlElement::MergeFrom(from.element());
    }
    if (from.has_text()) {
      set_has_text();
      text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (from.has_source()) {
      mutable_source()->::aapt::pb::SourcePosition::MergeFrom(from.source());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void XmlNode::CopyFrom(const XmlNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XmlNode::IsInitialized() const {

  return true;
}

void XmlNode::Swap(XmlNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void XmlNode::InternalSwap(XmlNode* other) {
  std::swap(element_, other->element_);
  text_.Swap(&other->text_);
  std::swap(source_, other->source_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string XmlNode::GetTypeName() const {
  return "aapt.pb.XmlNode";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// XmlNode

// optional .aapt.pb.XmlElement element = 1;
bool XmlNode::has_element() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void XmlNode::set_has_element() {
  _has_bits_[0] |= 0x00000001u;
}
void XmlNode::clear_has_element() {
  _has_bits_[0] &= ~0x00000001u;
}
void XmlNode::clear_element() {
  if (element_ != NULL) element_->::aapt::pb::XmlElement::Clear();
  clear_has_element();
}
const ::aapt::pb::XmlElement& XmlNode::element() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.element)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return element_ != NULL ? *element_ : *default_instance().element_;
#else
  return element_ != NULL ? *element_ : *default_instance_->element_;
#endif
}
::aapt::pb::XmlElement* XmlNode::mutable_element() {
  set_has_element();
  if (element_ == NULL) {
    element_ = new ::aapt::pb::XmlElement;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.element)
  return element_;
}
::aapt::pb::XmlElement* XmlNode::release_element() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.element)
  clear_has_element();
  ::aapt::pb::XmlElement* temp = element_;
  element_ = NULL;
  return temp;
}
void XmlNode::set_allocated_element(::aapt::pb::XmlElement* element) {
  delete element_;
  element_ = element;
  if (element) {
    set_has_element();
  } else {
    clear_has_element();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.element)
}

// optional string text = 2;
bool XmlNode::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void XmlNode::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
void XmlNode::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
void XmlNode::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
 const ::std::string& XmlNode::text() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlNode::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNode.text)
}
 void XmlNode::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlNode.text)
}
 void XmlNode::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlNode.text)
}
 ::std::string* XmlNode::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlNode::release_text() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlNode::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.text)
}

// optional .aapt.pb.SourcePosition source = 3;
bool XmlNode::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void XmlNode::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
void XmlNode::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
void XmlNode::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
  clear_has_source();
}
const ::aapt::pb::SourcePosition& XmlNode::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::SourcePosition* XmlNode::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.source)
  return source_;
}
::aapt::pb::SourcePosition* XmlNode::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.source)
  clear_has_source();
  ::aapt::pb::SourcePosition* temp = source_;
  source_ = NULL;
  return temp;
}
void XmlNode::set_allocated_source(::aapt::pb::SourcePosition* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.source)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForXmlElement(
    XmlElement* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int XmlElement::kNamespaceDeclarationFieldNumber;
const int XmlElement::kNamespaceUriFieldNumber;
const int XmlElement::kNameFieldNumber;
const int XmlElement::kAttributeFieldNumber;
const int XmlElement::kChildFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

XmlElement::XmlElement()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.XmlElement)
}

void XmlElement::InitAsDefaultInstance() {
}

XmlElement::XmlElement(const XmlElement& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlElement)
}

void XmlElement::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  namespace_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XmlElement::~XmlElement() {
  // @@protoc_insertion_point(destructor:aapt.pb.XmlElement)
  SharedDtor();
}

void XmlElement::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  namespace_uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void XmlElement::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const XmlElement& XmlElement::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

XmlElement* XmlElement::default_instance_ = NULL;

XmlElement* XmlElement::New(::google::protobuf::Arena* arena) const {
  XmlElement* n = new XmlElement;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void XmlElement::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlElement)
  if (_has_bits_[0 / 32] & 6u) {
    if (has_namespace_uri()) {
      namespace_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  namespace_declaration_.Clear();
  attribute_.Clear();
  child_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool XmlElement::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForXmlElement, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.XmlElement)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_namespace_declaration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_namespace_declaration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_namespace_declaration;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(18)) goto parse_namespace_uri;
        break;
      }

      // optional string namespace_uri = 2;
      case 2: {
        if (tag == 18) {
         parse_namespace_uri:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_uri()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_attribute;
        break;
      }

      // repeated .aapt.pb.XmlAttribute attribute = 4;
      case 4: {
        if (tag == 34) {
         parse_attribute:
          DO_(input->IncrementRecursionDepth());
         parse_loop_attribute:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_attribute()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_attribute;
        if (input->ExpectTag(42)) goto parse_loop_child;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .aapt.pb.XmlNode child = 5;
      case 5: {
        if (tag == 42) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_child:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_child()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_child;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.XmlElement)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.XmlElement)
  return false;
#undef DO_
}

void XmlElement::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.XmlElement)
  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
  for (unsigned int i = 0, n = this->namespace_declaration_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->namespace_declaration(i), output);
  }

  // optional string namespace_uri = 2;
  if (has_namespace_uri()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->namespace_uri(), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // repeated .aapt.pb.XmlAttribute attribute = 4;
  for (unsigned int i = 0, n = this->attribute_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->attribute(i), output);
  }

  // repeated .aapt.pb.XmlNode child = 5;
  for (unsigned int i = 0, n = this->child_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->child(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.XmlElement)
}

int XmlElement::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlElement)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 6u) {
    // optional string namespace_uri = 2;
    if (has_namespace_uri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->namespace_uri());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
  total_size += 1 * this->namespace_declaration_size();
  for (int i = 0; i < this->namespace_declaration_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->namespace_declaration(i));
  }

  // repeated .aapt.pb.XmlAttribute attribute = 4;
  total_size += 1 * this->attribute_size();
  for (int i = 0; i < this->attribute_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attribute(i));
  }

  // repeated .aapt.pb.XmlNode child = 5;
  total_size += 1 * this->child_size();
  for (int i = 0; i < this->child_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->child(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XmlElement::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const XmlElement*>(&from));
}

void XmlElement::MergeFrom(const XmlElement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlElement)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  namespace_declaration_.MergeFrom(from.namespace_declaration_);
  attribute_.MergeFrom(from.attribute_);
  child_.MergeFrom(from.child_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_namespace_uri()) {
      set_has_namespace_uri();
      namespace_uri_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace_uri_);
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void XmlElement::CopyFrom(const XmlElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XmlElement::IsInitialized() const {

  return true;
}

void XmlElement::Swap(XmlElement* other) {
  if (other == this) return;
  InternalSwap(other);
}
void XmlElement::InternalSwap(XmlElement* other) {
  namespace_declaration_.UnsafeArenaSwap(&other->namespace_declaration_);
  namespace_uri_.Swap(&other->namespace_uri_);
  name_.Swap(&other->name_);
  attribute_.UnsafeArenaSwap(&other->attribute_);
  child_.UnsafeArenaSwap(&other->child_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string XmlElement::GetTypeName() const {
  return "aapt.pb.XmlElement";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// XmlElement

// repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
int XmlElement::namespace_declaration_size() const {
  return namespace_declaration_.size();
}
void XmlElement::clear_namespace_declaration() {
  namespace_declaration_.Clear();
}
const ::aapt::pb::XmlNamespace& XmlElement::namespace_declaration(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_.Get(index);
}
::aapt::pb::XmlNamespace* XmlElement::mutable_namespace_declaration(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_.Mutable(index);
}
::aapt::pb::XmlNamespace* XmlElement::add_namespace_declaration() {
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
XmlElement::mutable_namespace_declaration() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.namespace_declaration)
  return &namespace_declaration_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
XmlElement::namespace_declaration() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_;
}

// optional string namespace_uri = 2;
bool XmlElement::has_namespace_uri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void XmlElement::set_has_namespace_uri() {
  _has_bits_[0] |= 0x00000002u;
}
void XmlElement::clear_has_namespace_uri() {
  _has_bits_[0] &= ~0x00000002u;
}
void XmlElement::clear_namespace_uri() {
  namespace_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_uri();
}
 const ::std::string& XmlElement::namespace_uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_uri)
  return namespace_uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlElement::set_namespace_uri(const ::std::string& value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.namespace_uri)
}
 void XmlElement::set_namespace_uri(const char* value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlElement.namespace_uri)
}
 void XmlElement::set_namespace_uri(const char* value, size_t size) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlElement.namespace_uri)
}
 ::std::string* XmlElement::mutable_namespace_uri() {
  set_has_namespace_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_uri)
  return namespace_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlElement::release_namespace_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.namespace_uri)
  clear_has_namespace_uri();
  return namespace_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlElement::set_allocated_namespace_uri(::std::string* namespace_uri) {
  if (namespace_uri != NULL) {
    set_has_namespace_uri();
  } else {
    clear_has_namespace_uri();
  }
  namespace_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_uri);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.namespace_uri)
}

// optional string name = 3;
bool XmlElement::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void XmlElement::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
void XmlElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void XmlElement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& XmlElement::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlElement::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.name)
}
 void XmlElement::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlElement.name)
}
 void XmlElement::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlElement.name)
}
 ::std::string* XmlElement::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlElement::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlElement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.name)
}

// repeated .aapt.pb.XmlAttribute attribute = 4;
int XmlElement::attribute_size() const {
  return attribute_.size();
}
void XmlElement::clear_attribute() {
  attribute_.Clear();
}
const ::aapt::pb::XmlAttribute& XmlElement::attribute(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.attribute)
  return attribute_.Get(index);
}
::aapt::pb::XmlAttribute* XmlElement::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.attribute)
  return attribute_.Mutable(index);
}
::aapt::pb::XmlAttribute* XmlElement::add_attribute() {
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.attribute)
  return attribute_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
XmlElement::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.attribute)
  return &attribute_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
XmlElement::attribute() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.attribute)
  return attribute_;
}

// repeated .aapt.pb.XmlNode child = 5;
int XmlElement::child_size() const {
  return child_.size();
}
void XmlElement::clear_child() {
  child_.Clear();
}
const ::aapt::pb::XmlNode& XmlElement::child(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.child)
  return child_.Get(index);
}
::aapt::pb::XmlNode* XmlElement::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.child)
  return child_.Mutable(index);
}
::aapt::pb::XmlNode* XmlElement::add_child() {
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.child)
  return child_.Add();
}
::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode >*
XmlElement::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.child)
  return &child_;
}
const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode >&
XmlElement::child() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.child)
  return child_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForXmlNamespace(
    XmlNamespace* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int XmlNamespace::kPrefixFieldNumber;
const int XmlNamespace::kUriFieldNumber;
const int XmlNamespace::kSourceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

XmlNamespace::XmlNamespace()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.XmlNamespace)
}

void XmlNamespace::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::SourcePosition*>(
      ::aapt::pb::SourcePosition::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::SourcePosition*>(&::aapt::pb::SourcePosition::default_instance());
#endif
}

XmlNamespace::XmlNamespace(const XmlNamespace& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlNamespace)
}

void XmlNamespace::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XmlNamespace::~XmlNamespace() {
  // @@protoc_insertion_point(destructor:aapt.pb.XmlNamespace)
  SharedDtor();
}

void XmlNamespace::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
  }
}

void XmlNamespace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const XmlNamespace& XmlNamespace::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

XmlNamespace* XmlNamespace::default_instance_ = NULL;

XmlNamespace* XmlNamespace::New(::google::protobuf::Arena* arena) const {
  XmlNamespace* n = new XmlNamespace;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void XmlNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlNamespace)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_prefix()) {
      prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_uri()) {
      uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool XmlNamespace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForXmlNamespace, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.XmlNamespace)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string prefix = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_prefix()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_uri;
        break;
      }

      // optional string uri = 2;
      case 2: {
        if (tag == 18) {
         parse_uri:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uri()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source;
        break;
      }

      // optional .aapt.pb.SourcePosition source = 3;
      case 3: {
        if (tag == 26) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.XmlNamespace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.XmlNamespace)
  return false;
#undef DO_
}

void XmlNamespace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.XmlNamespace)
  // optional string prefix = 1;
  if (has_prefix()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->prefix(), output);
  }

  // optional string uri = 2;
  if (has_uri()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->uri(), output);
  }

  // optional .aapt.pb.SourcePosition source = 3;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->source_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.XmlNamespace)
}

int XmlNamespace::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlNamespace)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string prefix = 1;
    if (has_prefix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->prefix());
    }

    // optional string uri = 2;
    if (has_uri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uri());
    }

    // optional .aapt.pb.SourcePosition source = 3;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XmlNamespace::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const XmlNamespace*>(&from));
}

void XmlNamespace::MergeFrom(const XmlNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlNamespace)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_prefix()) {
      set_has_prefix();
      prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
    }
    if (from.has_uri()) {
      set_has_uri();
      uri_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uri_);
    }
    if (from.has_source()) {
      mutable_source()->::aapt::pb::SourcePosition::MergeFrom(from.source());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void XmlNamespace::CopyFrom(const XmlNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XmlNamespace::IsInitialized() const {

  return true;
}

void XmlNamespace::Swap(XmlNamespace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void XmlNamespace::InternalSwap(XmlNamespace* other) {
  prefix_.Swap(&other->prefix_);
  uri_.Swap(&other->uri_);
  std::swap(source_, other->source_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string XmlNamespace::GetTypeName() const {
  return "aapt.pb.XmlNamespace";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// XmlNamespace

// optional string prefix = 1;
bool XmlNamespace::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void XmlNamespace::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
void XmlNamespace::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
void XmlNamespace::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix();
}
 const ::std::string& XmlNamespace::prefix() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.prefix)
  return prefix_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlNamespace::set_prefix(const ::std::string& value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.prefix)
}
 void XmlNamespace::set_prefix(const char* value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlNamespace.prefix)
}
 void XmlNamespace::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlNamespace.prefix)
}
 ::std::string* XmlNamespace::mutable_prefix() {
  set_has_prefix();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlNamespace::release_prefix() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.prefix)
  clear_has_prefix();
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlNamespace::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.prefix)
}

// optional string uri = 2;
bool XmlNamespace::has_uri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void XmlNamespace::set_has_uri() {
  _has_bits_[0] |= 0x00000002u;
}
void XmlNamespace::clear_has_uri() {
  _has_bits_[0] &= ~0x00000002u;
}
void XmlNamespace::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
 const ::std::string& XmlNamespace::uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.uri)
  return uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlNamespace::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.uri)
}
 void XmlNamespace::set_uri(const char* value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlNamespace.uri)
}
 void XmlNamespace::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlNamespace.uri)
}
 ::std::string* XmlNamespace::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlNamespace::release_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.uri)
  clear_has_uri();
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlNamespace::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.uri)
}

// optional .aapt.pb.SourcePosition source = 3;
bool XmlNamespace::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void XmlNamespace::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
void XmlNamespace::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
void XmlNamespace::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
  clear_has_source();
}
const ::aapt::pb::SourcePosition& XmlNamespace::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::SourcePosition* XmlNamespace::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.source)
  return source_;
}
::aapt::pb::SourcePosition* XmlNamespace::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.source)
  clear_has_source();
  ::aapt::pb::SourcePosition* temp = source_;
  source_ = NULL;
  return temp;
}
void XmlNamespace::set_allocated_source(::aapt::pb::SourcePosition* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.source)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForXmlAttribute(
    XmlAttribute* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int XmlAttribute::kNamespaceUriFieldNumber;
const int XmlAttribute::kNameFieldNumber;
const int XmlAttribute::kValueFieldNumber;
const int XmlAttribute::kSourceFieldNumber;
const int XmlAttribute::kResourceIdFieldNumber;
const int XmlAttribute::kCompiledItemFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

XmlAttribute::XmlAttribute()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:aapt.pb.XmlAttribute)
}

void XmlAttribute::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  source_ = const_cast< ::aapt::pb::SourcePosition*>(
      ::aapt::pb::SourcePosition::internal_default_instance());
#else
  source_ = const_cast< ::aapt::pb::SourcePosition*>(&::aapt::pb::SourcePosition::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  compiled_item_ = const_cast< ::aapt::pb::Item*>(
      ::aapt::pb::Item::internal_default_instance());
#else
  compiled_item_ = const_cast< ::aapt::pb::Item*>(&::aapt::pb::Item::default_instance());
#endif
}

XmlAttribute::XmlAttribute(const XmlAttribute& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aapt.pb.XmlAttribute)
}

void XmlAttribute::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  namespace_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
  resource_id_ = 0u;
  compiled_item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XmlAttribute::~XmlAttribute() {
  // @@protoc_insertion_point(destructor:aapt.pb.XmlAttribute)
  SharedDtor();
}

void XmlAttribute::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  namespace_uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete source_;
    delete compiled_item_;
  }
}

void XmlAttribute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const XmlAttribute& XmlAttribute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
#endif
  return *default_instance_;
}

XmlAttribute* XmlAttribute::default_instance_ = NULL;

XmlAttribute* XmlAttribute::New(::google::protobuf::Arena* arena) const {
  XmlAttribute* n = new XmlAttribute;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void XmlAttribute::Clear() {
// @@protoc_insertion_point(message_clear_start:aapt.pb.XmlAttribute)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_namespace_uri()) {
      namespace_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_source()) {
      if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
    }
    resource_id_ = 0u;
    if (has_compiled_item()) {
      if (compiled_item_ != NULL) compiled_item_->::aapt::pb::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool XmlAttribute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForXmlAttribute, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:aapt.pb.XmlAttribute)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string namespace_uri = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_uri()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional string value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_source;
        break;
      }

      // optional .aapt.pb.SourcePosition source = 4;
      case 4: {
        if (tag == 34) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_resource_id;
        break;
      }

      // optional uint32 resource_id = 5;
      case 5: {
        if (tag == 40) {
         parse_resource_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &resource_id_)));
          set_has_resource_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_compiled_item;
        break;
      }

      // optional .aapt.pb.Item compiled_item = 6;
      case 6: {
        if (tag == 50) {
         parse_compiled_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compiled_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aapt.pb.XmlAttribute)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aapt.pb.XmlAttribute)
  return false;
#undef DO_
}

void XmlAttribute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aapt.pb.XmlAttribute)
  // optional string namespace_uri = 1;
  if (has_namespace_uri()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->namespace_uri(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->value(), output);
  }

  // optional .aapt.pb.SourcePosition source = 4;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->source_, output);
  }

  // optional uint32 resource_id = 5;
  if (has_resource_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->resource_id(), output);
  }

  // optional .aapt.pb.Item compiled_item = 6;
  if (has_compiled_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->compiled_item_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:aapt.pb.XmlAttribute)
}

int XmlAttribute::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:aapt.pb.XmlAttribute)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional string namespace_uri = 1;
    if (has_namespace_uri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->namespace_uri());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional .aapt.pb.SourcePosition source = 4;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

    // optional uint32 resource_id = 5;
    if (has_resource_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->resource_id());
    }

    // optional .aapt.pb.Item compiled_item = 6;
    if (has_compiled_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->compiled_item_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XmlAttribute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const XmlAttribute*>(&from));
}

void XmlAttribute::MergeFrom(const XmlAttribute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aapt.pb.XmlAttribute)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_namespace_uri()) {
      set_has_namespace_uri();
      namespace_uri_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace_uri_);
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_source()) {
      mutable_source()->::aapt::pb::SourcePosition::MergeFrom(from.source());
    }
    if (from.has_resource_id()) {
      set_resource_id(from.resource_id());
    }
    if (from.has_compiled_item()) {
      mutable_compiled_item()->::aapt::pb::Item::MergeFrom(from.compiled_item());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void XmlAttribute::CopyFrom(const XmlAttribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aapt.pb.XmlAttribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XmlAttribute::IsInitialized() const {

  return true;
}

void XmlAttribute::Swap(XmlAttribute* other) {
  if (other == this) return;
  InternalSwap(other);
}
void XmlAttribute::InternalSwap(XmlAttribute* other) {
  namespace_uri_.Swap(&other->namespace_uri_);
  name_.Swap(&other->name_);
  value_.Swap(&other->value_);
  std::swap(source_, other->source_);
  std::swap(resource_id_, other->resource_id_);
  std::swap(compiled_item_, other->compiled_item_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string XmlAttribute::GetTypeName() const {
  return "aapt.pb.XmlAttribute";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// XmlAttribute

// optional string namespace_uri = 1;
bool XmlAttribute::has_namespace_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void XmlAttribute::set_has_namespace_uri() {
  _has_bits_[0] |= 0x00000001u;
}
void XmlAttribute::clear_has_namespace_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
void XmlAttribute::clear_namespace_uri() {
  namespace_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_uri();
}
 const ::std::string& XmlAttribute::namespace_uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.namespace_uri)
  return namespace_uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlAttribute::set_namespace_uri(const ::std::string& value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.namespace_uri)
}
 void XmlAttribute::set_namespace_uri(const char* value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlAttribute.namespace_uri)
}
 void XmlAttribute::set_namespace_uri(const char* value, size_t size) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlAttribute.namespace_uri)
}
 ::std::string* XmlAttribute::mutable_namespace_uri() {
  set_has_namespace_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.namespace_uri)
  return namespace_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlAttribute::release_namespace_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.namespace_uri)
  clear_has_namespace_uri();
  return namespace_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlAttribute::set_allocated_namespace_uri(::std::string* namespace_uri) {
  if (namespace_uri != NULL) {
    set_has_namespace_uri();
  } else {
    clear_has_namespace_uri();
  }
  namespace_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_uri);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.namespace_uri)
}

// optional string name = 2;
bool XmlAttribute::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void XmlAttribute::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void XmlAttribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void XmlAttribute::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& XmlAttribute::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlAttribute::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.name)
}
 void XmlAttribute::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlAttribute.name)
}
 void XmlAttribute::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlAttribute.name)
}
 ::std::string* XmlAttribute::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlAttribute::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlAttribute::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.name)
}

// optional string value = 3;
bool XmlAttribute::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void XmlAttribute::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
void XmlAttribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void XmlAttribute::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& XmlAttribute::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlAttribute::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.value)
}
 void XmlAttribute::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlAttribute.value)
}
 void XmlAttribute::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlAttribute.value)
}
 ::std::string* XmlAttribute::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* XmlAttribute::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void XmlAttribute::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.value)
}

// optional .aapt.pb.SourcePosition source = 4;
bool XmlAttribute::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void XmlAttribute::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
void XmlAttribute::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
void XmlAttribute::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
  clear_has_source();
}
const ::aapt::pb::SourcePosition& XmlAttribute::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
::aapt::pb::SourcePosition* XmlAttribute::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.source)
  return source_;
}
::aapt::pb::SourcePosition* XmlAttribute::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.source)
  clear_has_source();
  ::aapt::pb::SourcePosition* temp = source_;
  source_ = NULL;
  return temp;
}
void XmlAttribute::set_allocated_source(::aapt::pb::SourcePosition* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.source)
}

// optional uint32 resource_id = 5;
bool XmlAttribute::has_resource_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void XmlAttribute::set_has_resource_id() {
  _has_bits_[0] |= 0x00000010u;
}
void XmlAttribute::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void XmlAttribute::clear_resource_id() {
  resource_id_ = 0u;
  clear_has_resource_id();
}
 ::google::protobuf::uint32 XmlAttribute::resource_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.resource_id)
  return resource_id_;
}
 void XmlAttribute::set_resource_id(::google::protobuf::uint32 value) {
  set_has_resource_id();
  resource_id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.resource_id)
}

// optional .aapt.pb.Item compiled_item = 6;
bool XmlAttribute::has_compiled_item() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void XmlAttribute::set_has_compiled_item() {
  _has_bits_[0] |= 0x00000020u;
}
void XmlAttribute::clear_has_compiled_item() {
  _has_bits_[0] &= ~0x00000020u;
}
void XmlAttribute::clear_compiled_item() {
  if (compiled_item_ != NULL) compiled_item_->::aapt::pb::Item::Clear();
  clear_has_compiled_item();
}
const ::aapt::pb::Item& XmlAttribute::compiled_item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.compiled_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compiled_item_ != NULL ? *compiled_item_ : *default_instance().compiled_item_;
#else
  return compiled_item_ != NULL ? *compiled_item_ : *default_instance_->compiled_item_;
#endif
}
::aapt::pb::Item* XmlAttribute::mutable_compiled_item() {
  set_has_compiled_item();
  if (compiled_item_ == NULL) {
    compiled_item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.compiled_item)
  return compiled_item_;
}
::aapt::pb::Item* XmlAttribute::release_compiled_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.compiled_item)
  clear_has_compiled_item();
  ::aapt::pb::Item* temp = compiled_item_;
  compiled_item_ = NULL;
  return temp;
}
void XmlAttribute::set_allocated_compiled_item(::aapt::pb::Item* compiled_item) {
  delete compiled_item_;
  compiled_item_ = compiled_item;
  if (compiled_item) {
    set_has_compiled_item();
  } else {
    clear_has_compiled_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.compiled_item)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

// @@protoc_insertion_point(global_scope)
