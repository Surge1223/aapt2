// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/base/tools/aapt2/Resources.proto

#ifndef PROTOBUF_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto__INCLUDED
#define PROTOBUF_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace aapt {
namespace pb {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

class Array;
class Array_Element;
class Attribute;
class Attribute_Symbol;
class CompoundValue;
class ConfigDescription;
class ConfigValue;
class Entry;
class FileReference;
class Id;
class Item;
class Package;
class Plural;
class Plural_Entry;
class Primitive;
class RawString;
class Reference;
class ResourceTable;
class Source;
class SourcePosition;
class String;
class StringPool;
class Style;
class Style_Entry;
class Styleable;
class Styleable_Entry;
class StyledString;
class StyledString_Span;
class SymbolStatus;
class Type;
class Value;
class XmlAttribute;
class XmlElement;
class XmlNamespace;
class XmlNode;

enum SymbolStatus_Visibility {
  SymbolStatus_Visibility_UNKNOWN = 0,
  SymbolStatus_Visibility_PRIVATE = 1,
  SymbolStatus_Visibility_PUBLIC = 2
};
bool SymbolStatus_Visibility_IsValid(int value);
const SymbolStatus_Visibility SymbolStatus_Visibility_Visibility_MIN = SymbolStatus_Visibility_UNKNOWN;
const SymbolStatus_Visibility SymbolStatus_Visibility_Visibility_MAX = SymbolStatus_Visibility_PUBLIC;
const int SymbolStatus_Visibility_Visibility_ARRAYSIZE = SymbolStatus_Visibility_Visibility_MAX + 1;

enum Reference_Type {
  Reference_Type_REFERENCE = 0,
  Reference_Type_ATTRIBUTE = 1
};
bool Reference_Type_IsValid(int value);
const Reference_Type Reference_Type_Type_MIN = Reference_Type_REFERENCE;
const Reference_Type Reference_Type_Type_MAX = Reference_Type_ATTRIBUTE;
const int Reference_Type_Type_ARRAYSIZE = Reference_Type_Type_MAX + 1;

enum Attribute_FormatFlags {
  Attribute_FormatFlags_ANY = 65535,
  Attribute_FormatFlags_REFERENCE = 1,
  Attribute_FormatFlags_STRING = 2,
  Attribute_FormatFlags_INTEGER = 4,
  Attribute_FormatFlags_BOOLEAN = 8,
  Attribute_FormatFlags_COLOR = 16,
  Attribute_FormatFlags_FLOAT = 32,
  Attribute_FormatFlags_DIMENSION = 64,
  Attribute_FormatFlags_FRACTION = 128,
  Attribute_FormatFlags_ENUM = 65536,
  Attribute_FormatFlags_FLAGS = 131072
};
bool Attribute_FormatFlags_IsValid(int value);
const Attribute_FormatFlags Attribute_FormatFlags_FormatFlags_MIN = Attribute_FormatFlags_REFERENCE;
const Attribute_FormatFlags Attribute_FormatFlags_FormatFlags_MAX = Attribute_FormatFlags_FLAGS;
const int Attribute_FormatFlags_FormatFlags_ARRAYSIZE = Attribute_FormatFlags_FormatFlags_MAX + 1;

enum Plural_Arity {
  Plural_Arity_ZERO = 0,
  Plural_Arity_ONE = 1,
  Plural_Arity_TWO = 2,
  Plural_Arity_FEW = 3,
  Plural_Arity_MANY = 4,
  Plural_Arity_OTHER = 5
};
bool Plural_Arity_IsValid(int value);
const Plural_Arity Plural_Arity_Arity_MIN = Plural_Arity_ZERO;
const Plural_Arity Plural_Arity_Arity_MAX = Plural_Arity_OTHER;
const int Plural_Arity_Arity_ARRAYSIZE = Plural_Arity_Arity_MAX + 1;

// ===================================================================

class ConfigDescription : public ::google::protobuf::MessageLite {
 public:
  ConfigDescription();
  virtual ~ConfigDescription();

  ConfigDescription(const ConfigDescription& from);

  inline ConfigDescription& operator=(const ConfigDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ConfigDescription& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigDescription* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigDescription* other);

  // implements Message ----------------------------------------------

  inline ConfigDescription* New() const { return New(NULL); }

  ConfigDescription* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigDescription& from);
  void MergeFrom(const ConfigDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional string product = 2;
  bool has_product() const;
  void clear_product();
  static const int kProductFieldNumber = 2;
  const ::std::string& product() const;
  void set_product(const ::std::string& value);
  void set_product(const char* value);
  void set_product(const char* value, size_t size);
  ::std::string* mutable_product();
  ::std::string* release_product();
  void set_allocated_product(::std::string* product);

  // @@protoc_insertion_point(class_scope:aapt.pb.ConfigDescription)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_product();
  inline void clear_has_product();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr product_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static ConfigDescription* default_instance_;
};
// -------------------------------------------------------------------

class StringPool : public ::google::protobuf::MessageLite {
 public:
  StringPool();
  virtual ~StringPool();

  StringPool(const StringPool& from);

  inline StringPool& operator=(const StringPool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StringPool& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StringPool* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StringPool* other);

  // implements Message ----------------------------------------------

  inline StringPool* New() const { return New(NULL); }

  StringPool* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StringPool& from);
  void MergeFrom(const StringPool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringPool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:aapt.pb.StringPool)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static StringPool* default_instance_;
};
// -------------------------------------------------------------------

class SourcePosition : public ::google::protobuf::MessageLite {
 public:
  SourcePosition();
  virtual ~SourcePosition();

  SourcePosition(const SourcePosition& from);

  inline SourcePosition& operator=(const SourcePosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SourcePosition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SourcePosition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SourcePosition* other);

  // implements Message ----------------------------------------------

  inline SourcePosition* New() const { return New(NULL); }

  SourcePosition* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SourcePosition& from);
  void MergeFrom(const SourcePosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SourcePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 line_number = 1;
  bool has_line_number() const;
  void clear_line_number();
  static const int kLineNumberFieldNumber = 1;
  ::google::protobuf::uint32 line_number() const;
  void set_line_number(::google::protobuf::uint32 value);

  // optional uint32 column_number = 2;
  bool has_column_number() const;
  void clear_column_number();
  static const int kColumnNumberFieldNumber = 2;
  ::google::protobuf::uint32 column_number() const;
  void set_column_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.SourcePosition)
 private:
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_column_number();
  inline void clear_has_column_number();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 line_number_;
  ::google::protobuf::uint32 column_number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static SourcePosition* default_instance_;
};
// -------------------------------------------------------------------

class Source : public ::google::protobuf::MessageLite {
 public:
  Source();
  virtual ~Source();

  Source(const Source& from);

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Source& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Source* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Source* other);

  // implements Message ----------------------------------------------

  inline Source* New() const { return New(NULL); }

  Source* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Source* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 path_idx = 1;
  bool has_path_idx() const;
  void clear_path_idx();
  static const int kPathIdxFieldNumber = 1;
  ::google::protobuf::uint32 path_idx() const;
  void set_path_idx(::google::protobuf::uint32 value);

  // optional .aapt.pb.SourcePosition position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::aapt::pb::SourcePosition& position() const;
  ::aapt::pb::SourcePosition* mutable_position();
  ::aapt::pb::SourcePosition* release_position();
  void set_allocated_position(::aapt::pb::SourcePosition* position);

  // @@protoc_insertion_point(class_scope:aapt.pb.Source)
 private:
  inline void set_has_path_idx();
  inline void clear_has_path_idx();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::SourcePosition* position_;
  ::google::protobuf::uint32 path_idx_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Source* default_instance_;
};
// -------------------------------------------------------------------

class ResourceTable : public ::google::protobuf::MessageLite {
 public:
  ResourceTable();
  virtual ~ResourceTable();

  ResourceTable(const ResourceTable& from);

  inline ResourceTable& operator=(const ResourceTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ResourceTable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResourceTable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResourceTable* other);

  // implements Message ----------------------------------------------

  inline ResourceTable* New() const { return New(NULL); }

  ResourceTable* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResourceTable& from);
  void MergeFrom(const ResourceTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResourceTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.StringPool source_pool = 1;
  bool has_source_pool() const;
  void clear_source_pool();
  static const int kSourcePoolFieldNumber = 1;
  const ::aapt::pb::StringPool& source_pool() const;
  ::aapt::pb::StringPool* mutable_source_pool();
  ::aapt::pb::StringPool* release_source_pool();
  void set_allocated_source_pool(::aapt::pb::StringPool* source_pool);

  // repeated .aapt.pb.Package package = 2;
  int package_size() const;
  void clear_package();
  static const int kPackageFieldNumber = 2;
  const ::aapt::pb::Package& package(int index) const;
  ::aapt::pb::Package* mutable_package(int index);
  ::aapt::pb::Package* add_package();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >*
      mutable_package();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >&
      package() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.ResourceTable)
 private:
  inline void set_has_source_pool();
  inline void clear_has_source_pool();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::StringPool* source_pool_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package > package_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static ResourceTable* default_instance_;
};
// -------------------------------------------------------------------

class Package : public ::google::protobuf::MessageLite {
 public:
  Package();
  virtual ~Package();

  Package(const Package& from);

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Package& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Package* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Package* other);

  // implements Message ----------------------------------------------

  inline Package* New() const { return New(NULL); }

  Package* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Package& from);
  void MergeFrom(const Package& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Package* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 package_id = 1;
  bool has_package_id() const;
  void clear_package_id();
  static const int kPackageIdFieldNumber = 1;
  ::google::protobuf::uint32 package_id() const;
  void set_package_id(::google::protobuf::uint32 value);

  // optional string package_name = 2;
  bool has_package_name() const;
  void clear_package_name();
  static const int kPackageNameFieldNumber = 2;
  const ::std::string& package_name() const;
  void set_package_name(const ::std::string& value);
  void set_package_name(const char* value);
  void set_package_name(const char* value, size_t size);
  ::std::string* mutable_package_name();
  ::std::string* release_package_name();
  void set_allocated_package_name(::std::string* package_name);

  // repeated .aapt.pb.Type type = 3;
  int type_size() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::aapt::pb::Type& type(int index) const;
  ::aapt::pb::Type* mutable_type(int index);
  ::aapt::pb::Type* add_type();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >*
      mutable_type();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >&
      type() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Package)
 private:
  inline void set_has_package_id();
  inline void clear_has_package_id();
  inline void set_has_package_name();
  inline void clear_has_package_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr package_name_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type > type_;
  ::google::protobuf::uint32 package_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Package* default_instance_;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::MessageLite {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Type& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Type* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Type* other);

  // implements Message ----------------------------------------------

  inline Type* New() const { return New(NULL); }

  Type* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .aapt.pb.Entry entry = 3;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 3;
  const ::aapt::pb::Entry& entry(int index) const;
  ::aapt::pb::Entry* mutable_entry(int index);
  ::aapt::pb::Entry* add_entry();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >*
      mutable_entry();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Type)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry > entry_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Type* default_instance_;
};
// -------------------------------------------------------------------

class SymbolStatus : public ::google::protobuf::MessageLite {
 public:
  SymbolStatus();
  virtual ~SymbolStatus();

  SymbolStatus(const SymbolStatus& from);

  inline SymbolStatus& operator=(const SymbolStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SymbolStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SymbolStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SymbolStatus* other);

  // implements Message ----------------------------------------------

  inline SymbolStatus* New() const { return New(NULL); }

  SymbolStatus* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SymbolStatus& from);
  void MergeFrom(const SymbolStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SymbolStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SymbolStatus_Visibility Visibility;
  static const Visibility UNKNOWN =
    SymbolStatus_Visibility_UNKNOWN;
  static const Visibility PRIVATE =
    SymbolStatus_Visibility_PRIVATE;
  static const Visibility PUBLIC =
    SymbolStatus_Visibility_PUBLIC;
  static inline bool Visibility_IsValid(int value) {
    return SymbolStatus_Visibility_IsValid(value);
  }
  static const Visibility Visibility_MIN =
    SymbolStatus_Visibility_Visibility_MIN;
  static const Visibility Visibility_MAX =
    SymbolStatus_Visibility_Visibility_MAX;
  static const int Visibility_ARRAYSIZE =
    SymbolStatus_Visibility_Visibility_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
  bool has_visibility() const;
  void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  ::aapt::pb::SymbolStatus_Visibility visibility() const;
  void set_visibility(::aapt::pb::SymbolStatus_Visibility value);

  // optional .aapt.pb.Source source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 3;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional bool allow_new = 4;
  bool has_allow_new() const;
  void clear_allow_new();
  static const int kAllowNewFieldNumber = 4;
  bool allow_new() const;
  void set_allow_new(bool value);

  // @@protoc_insertion_point(class_scope:aapt.pb.SymbolStatus)
 private:
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_allow_new();
  inline void clear_has_allow_new();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  int visibility_;
  bool allow_new_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static SymbolStatus* default_instance_;
};
// -------------------------------------------------------------------

class Entry : public ::google::protobuf::MessageLite {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Entry* other);

  // implements Message ----------------------------------------------

  inline Entry* New() const { return New(NULL); }

  Entry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .aapt.pb.SymbolStatus symbol_status = 3;
  bool has_symbol_status() const;
  void clear_symbol_status();
  static const int kSymbolStatusFieldNumber = 3;
  const ::aapt::pb::SymbolStatus& symbol_status() const;
  ::aapt::pb::SymbolStatus* mutable_symbol_status();
  ::aapt::pb::SymbolStatus* release_symbol_status();
  void set_allocated_symbol_status(::aapt::pb::SymbolStatus* symbol_status);

  // repeated .aapt.pb.ConfigValue config_value = 4;
  int config_value_size() const;
  void clear_config_value();
  static const int kConfigValueFieldNumber = 4;
  const ::aapt::pb::ConfigValue& config_value(int index) const;
  ::aapt::pb::ConfigValue* mutable_config_value(int index);
  ::aapt::pb::ConfigValue* add_config_value();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >*
      mutable_config_value();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >&
      config_value() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Entry)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_symbol_status();
  inline void clear_has_symbol_status();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::aapt::pb::SymbolStatus* symbol_status_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue > config_value_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Entry* default_instance_;
};
// -------------------------------------------------------------------

class ConfigValue : public ::google::protobuf::MessageLite {
 public:
  ConfigValue();
  virtual ~ConfigValue();

  ConfigValue(const ConfigValue& from);

  inline ConfigValue& operator=(const ConfigValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ConfigValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigValue* other);

  // implements Message ----------------------------------------------

  inline ConfigValue* New() const { return New(NULL); }

  ConfigValue* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigValue& from);
  void MergeFrom(const ConfigValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.ConfigDescription config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::aapt::pb::ConfigDescription& config() const;
  ::aapt::pb::ConfigDescription* mutable_config();
  ::aapt::pb::ConfigDescription* release_config();
  void set_allocated_config(::aapt::pb::ConfigDescription* config);

  // optional .aapt.pb.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::aapt::pb::Value& value() const;
  ::aapt::pb::Value* mutable_value();
  ::aapt::pb::Value* release_value();
  void set_allocated_value(::aapt::pb::Value* value);

  // @@protoc_insertion_point(class_scope:aapt.pb.ConfigValue)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::ConfigDescription* config_;
  ::aapt::pb::Value* value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static ConfigValue* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::MessageLite {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Value& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Value* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  inline Value* New() const { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional bool weak = 3;
  bool has_weak() const;
  void clear_weak();
  static const int kWeakFieldNumber = 3;
  bool weak() const;
  void set_weak(bool value);

  // optional .aapt.pb.Item item = 4;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 4;
  const ::aapt::pb::Item& item() const;
  ::aapt::pb::Item* mutable_item();
  ::aapt::pb::Item* release_item();
  void set_allocated_item(::aapt::pb::Item* item);

  // optional .aapt.pb.CompoundValue compound_value = 5;
  bool has_compound_value() const;
  void clear_compound_value();
  static const int kCompoundValueFieldNumber = 5;
  const ::aapt::pb::CompoundValue& compound_value() const;
  ::aapt::pb::CompoundValue* mutable_compound_value();
  ::aapt::pb::CompoundValue* release_compound_value();
  void set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Value)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_weak();
  inline void clear_has_weak();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_compound_value();
  inline void clear_has_compound_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::aapt::pb::Item* item_;
  ::aapt::pb::CompoundValue* compound_value_;
  bool weak_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::MessageLite {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Item& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Item* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  inline Item* New() const { return New(NULL); }

  Item* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Reference ref = 1;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 1;
  const ::aapt::pb::Reference& ref() const;
  ::aapt::pb::Reference* mutable_ref();
  ::aapt::pb::Reference* release_ref();
  void set_allocated_ref(::aapt::pb::Reference* ref);

  // optional .aapt.pb.String str = 2;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 2;
  const ::aapt::pb::String& str() const;
  ::aapt::pb::String* mutable_str();
  ::aapt::pb::String* release_str();
  void set_allocated_str(::aapt::pb::String* str);

  // optional .aapt.pb.RawString raw_str = 3;
  bool has_raw_str() const;
  void clear_raw_str();
  static const int kRawStrFieldNumber = 3;
  const ::aapt::pb::RawString& raw_str() const;
  ::aapt::pb::RawString* mutable_raw_str();
  ::aapt::pb::RawString* release_raw_str();
  void set_allocated_raw_str(::aapt::pb::RawString* raw_str);

  // optional .aapt.pb.StyledString styled_str = 4;
  bool has_styled_str() const;
  void clear_styled_str();
  static const int kStyledStrFieldNumber = 4;
  const ::aapt::pb::StyledString& styled_str() const;
  ::aapt::pb::StyledString* mutable_styled_str();
  ::aapt::pb::StyledString* release_styled_str();
  void set_allocated_styled_str(::aapt::pb::StyledString* styled_str);

  // optional .aapt.pb.FileReference file = 5;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 5;
  const ::aapt::pb::FileReference& file() const;
  ::aapt::pb::FileReference* mutable_file();
  ::aapt::pb::FileReference* release_file();
  void set_allocated_file(::aapt::pb::FileReference* file);

  // optional .aapt.pb.Id id = 6;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 6;
  const ::aapt::pb::Id& id() const;
  ::aapt::pb::Id* mutable_id();
  ::aapt::pb::Id* release_id();
  void set_allocated_id(::aapt::pb::Id* id);

  // optional .aapt.pb.Primitive prim = 7;
  bool has_prim() const;
  void clear_prim();
  static const int kPrimFieldNumber = 7;
  const ::aapt::pb::Primitive& prim() const;
  ::aapt::pb::Primitive* mutable_prim();
  ::aapt::pb::Primitive* release_prim();
  void set_allocated_prim(::aapt::pb::Primitive* prim);

  // @@protoc_insertion_point(class_scope:aapt.pb.Item)
 private:
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_raw_str();
  inline void clear_has_raw_str();
  inline void set_has_styled_str();
  inline void clear_has_styled_str();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_prim();
  inline void clear_has_prim();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Reference* ref_;
  ::aapt::pb::String* str_;
  ::aapt::pb::RawString* raw_str_;
  ::aapt::pb::StyledString* styled_str_;
  ::aapt::pb::FileReference* file_;
  ::aapt::pb::Id* id_;
  ::aapt::pb::Primitive* prim_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class CompoundValue : public ::google::protobuf::MessageLite {
 public:
  CompoundValue();
  virtual ~CompoundValue();

  CompoundValue(const CompoundValue& from);

  inline CompoundValue& operator=(const CompoundValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CompoundValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompoundValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompoundValue* other);

  // implements Message ----------------------------------------------

  inline CompoundValue* New() const { return New(NULL); }

  CompoundValue* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompoundValue& from);
  void MergeFrom(const CompoundValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CompoundValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Attribute attr = 1;
  bool has_attr() const;
  void clear_attr();
  static const int kAttrFieldNumber = 1;
  const ::aapt::pb::Attribute& attr() const;
  ::aapt::pb::Attribute* mutable_attr();
  ::aapt::pb::Attribute* release_attr();
  void set_allocated_attr(::aapt::pb::Attribute* attr);

  // optional .aapt.pb.Style style = 2;
  bool has_style() const;
  void clear_style();
  static const int kStyleFieldNumber = 2;
  const ::aapt::pb::Style& style() const;
  ::aapt::pb::Style* mutable_style();
  ::aapt::pb::Style* release_style();
  void set_allocated_style(::aapt::pb::Style* style);

  // optional .aapt.pb.Styleable styleable = 3;
  bool has_styleable() const;
  void clear_styleable();
  static const int kStyleableFieldNumber = 3;
  const ::aapt::pb::Styleable& styleable() const;
  ::aapt::pb::Styleable* mutable_styleable();
  ::aapt::pb::Styleable* release_styleable();
  void set_allocated_styleable(::aapt::pb::Styleable* styleable);

  // optional .aapt.pb.Array array = 4;
  bool has_array() const;
  void clear_array();
  static const int kArrayFieldNumber = 4;
  const ::aapt::pb::Array& array() const;
  ::aapt::pb::Array* mutable_array();
  ::aapt::pb::Array* release_array();
  void set_allocated_array(::aapt::pb::Array* array);

  // optional .aapt.pb.Plural plural = 5;
  bool has_plural() const;
  void clear_plural();
  static const int kPluralFieldNumber = 5;
  const ::aapt::pb::Plural& plural() const;
  ::aapt::pb::Plural* mutable_plural();
  ::aapt::pb::Plural* release_plural();
  void set_allocated_plural(::aapt::pb::Plural* plural);

  // @@protoc_insertion_point(class_scope:aapt.pb.CompoundValue)
 private:
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_styleable();
  inline void clear_has_styleable();
  inline void set_has_array();
  inline void clear_has_array();
  inline void set_has_plural();
  inline void clear_has_plural();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Attribute* attr_;
  ::aapt::pb::Style* style_;
  ::aapt::pb::Styleable* styleable_;
  ::aapt::pb::Array* array_;
  ::aapt::pb::Plural* plural_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static CompoundValue* default_instance_;
};
// -------------------------------------------------------------------

class Reference : public ::google::protobuf::MessageLite {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Reference& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reference* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reference* other);

  // implements Message ----------------------------------------------

  inline Reference* New() const { return New(NULL); }

  Reference* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reference& from);
  void MergeFrom(const Reference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Reference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Reference_Type Type;
  static const Type REFERENCE =
    Reference_Type_REFERENCE;
  static const Type ATTRIBUTE =
    Reference_Type_ATTRIBUTE;
  static inline bool Type_IsValid(int value) {
    return Reference_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Reference_Type_Type_MIN;
  static const Type Type_MAX =
    Reference_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Reference_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Reference.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::aapt::pb::Reference_Type type() const;
  void set_type(::aapt::pb::Reference_Type value);

  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool private = 4;
  bool has_private_() const;
  void clear_private_();
  static const int kPrivateFieldNumber = 4;
  bool private_() const;
  void set_private_(bool value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Reference)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_private_();
  inline void clear_has_private_();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool private__;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Reference* default_instance_;
};
// -------------------------------------------------------------------

class Id : public ::google::protobuf::MessageLite {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Id& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Id* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Id* other);

  // implements Message ----------------------------------------------

  inline Id* New() const { return New(NULL); }

  Id* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Id* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aapt.pb.Id)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Id* default_instance_;
};
// -------------------------------------------------------------------

class String : public ::google::protobuf::MessageLite {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const String& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const String* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(String* other);

  // implements Message ----------------------------------------------

  inline String* New() const { return New(NULL); }

  String* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:aapt.pb.String)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static String* default_instance_;
};
// -------------------------------------------------------------------

class RawString : public ::google::protobuf::MessageLite {
 public:
  RawString();
  virtual ~RawString();

  RawString(const RawString& from);

  inline RawString& operator=(const RawString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RawString& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RawString* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RawString* other);

  // implements Message ----------------------------------------------

  inline RawString* New() const { return New(NULL); }

  RawString* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RawString& from);
  void MergeFrom(const RawString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:aapt.pb.RawString)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static RawString* default_instance_;
};
// -------------------------------------------------------------------

class StyledString_Span : public ::google::protobuf::MessageLite {
 public:
  StyledString_Span();
  virtual ~StyledString_Span();

  StyledString_Span(const StyledString_Span& from);

  inline StyledString_Span& operator=(const StyledString_Span& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StyledString_Span& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StyledString_Span* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StyledString_Span* other);

  // implements Message ----------------------------------------------

  inline StyledString_Span* New() const { return New(NULL); }

  StyledString_Span* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StyledString_Span& from);
  void MergeFrom(const StyledString_Span& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StyledString_Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // optional uint32 first_char = 2;
  bool has_first_char() const;
  void clear_first_char();
  static const int kFirstCharFieldNumber = 2;
  ::google::protobuf::uint32 first_char() const;
  void set_first_char(::google::protobuf::uint32 value);

  // optional uint32 last_char = 3;
  bool has_last_char() const;
  void clear_last_char();
  static const int kLastCharFieldNumber = 3;
  ::google::protobuf::uint32 last_char() const;
  void set_last_char(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.StyledString.Span)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_first_char();
  inline void clear_has_first_char();
  inline void set_has_last_char();
  inline void clear_has_last_char();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::uint32 first_char_;
  ::google::protobuf::uint32 last_char_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static StyledString_Span* default_instance_;
};
// -------------------------------------------------------------------

class StyledString : public ::google::protobuf::MessageLite {
 public:
  StyledString();
  virtual ~StyledString();

  StyledString(const StyledString& from);

  inline StyledString& operator=(const StyledString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StyledString& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StyledString* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StyledString* other);

  // implements Message ----------------------------------------------

  inline StyledString* New() const { return New(NULL); }

  StyledString* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StyledString& from);
  void MergeFrom(const StyledString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StyledString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef StyledString_Span Span;

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // repeated .aapt.pb.StyledString.Span span = 2;
  int span_size() const;
  void clear_span();
  static const int kSpanFieldNumber = 2;
  const ::aapt::pb::StyledString_Span& span(int index) const;
  ::aapt::pb::StyledString_Span* mutable_span(int index);
  ::aapt::pb::StyledString_Span* add_span();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
      mutable_span();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
      span() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.StyledString)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span > span_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static StyledString* default_instance_;
};
// -------------------------------------------------------------------

class FileReference : public ::google::protobuf::MessageLite {
 public:
  FileReference();
  virtual ~FileReference();

  FileReference(const FileReference& from);

  inline FileReference& operator=(const FileReference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FileReference& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileReference* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileReference* other);

  // implements Message ----------------------------------------------

  inline FileReference* New() const { return New(NULL); }

  FileReference* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileReference& from);
  void MergeFrom(const FileReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:aapt.pb.FileReference)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static FileReference* default_instance_;
};
// -------------------------------------------------------------------

class Primitive : public ::google::protobuf::MessageLite {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Primitive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Primitive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Primitive* other);

  // implements Message ----------------------------------------------

  inline Primitive* New() const { return New(NULL); }

  Primitive* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Primitive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::google::protobuf::uint32 data() const;
  void set_data(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Primitive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Primitive* default_instance_;
};
// -------------------------------------------------------------------

class Attribute_Symbol : public ::google::protobuf::MessageLite {
 public:
  Attribute_Symbol();
  virtual ~Attribute_Symbol();

  Attribute_Symbol(const Attribute_Symbol& from);

  inline Attribute_Symbol& operator=(const Attribute_Symbol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Attribute_Symbol& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Attribute_Symbol* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Attribute_Symbol* other);

  // implements Message ----------------------------------------------

  inline Attribute_Symbol* New() const { return New(NULL); }

  Attribute_Symbol* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attribute_Symbol& from);
  void MergeFrom(const Attribute_Symbol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Attribute_Symbol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Reference name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::aapt::pb::Reference& name() const;
  ::aapt::pb::Reference* mutable_name();
  ::aapt::pb::Reference* release_name();
  void set_allocated_name(::aapt::pb::Reference* name);

  // optional uint32 value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute.Symbol)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::aapt::pb::Reference* name_;
  ::google::protobuf::uint32 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Attribute_Symbol* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::MessageLite {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Attribute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Attribute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Attribute* other);

  // implements Message ----------------------------------------------

  inline Attribute* New() const { return New(NULL); }

  Attribute* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Attribute_Symbol Symbol;

  typedef Attribute_FormatFlags FormatFlags;
  static const FormatFlags ANY =
    Attribute_FormatFlags_ANY;
  static const FormatFlags REFERENCE =
    Attribute_FormatFlags_REFERENCE;
  static const FormatFlags STRING =
    Attribute_FormatFlags_STRING;
  static const FormatFlags INTEGER =
    Attribute_FormatFlags_INTEGER;
  static const FormatFlags BOOLEAN =
    Attribute_FormatFlags_BOOLEAN;
  static const FormatFlags COLOR =
    Attribute_FormatFlags_COLOR;
  static const FormatFlags FLOAT =
    Attribute_FormatFlags_FLOAT;
  static const FormatFlags DIMENSION =
    Attribute_FormatFlags_DIMENSION;
  static const FormatFlags FRACTION =
    Attribute_FormatFlags_FRACTION;
  static const FormatFlags ENUM =
    Attribute_FormatFlags_ENUM;
  static const FormatFlags FLAGS =
    Attribute_FormatFlags_FLAGS;
  static inline bool FormatFlags_IsValid(int value) {
    return Attribute_FormatFlags_IsValid(value);
  }
  static const FormatFlags FormatFlags_MIN =
    Attribute_FormatFlags_FormatFlags_MIN;
  static const FormatFlags FormatFlags_MAX =
    Attribute_FormatFlags_FormatFlags_MAX;
  static const int FormatFlags_ARRAYSIZE =
    Attribute_FormatFlags_FormatFlags_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 format_flags = 1;
  bool has_format_flags() const;
  void clear_format_flags();
  static const int kFormatFlagsFieldNumber = 1;
  ::google::protobuf::uint32 format_flags() const;
  void set_format_flags(::google::protobuf::uint32 value);

  // optional int32 min_int = 2;
  bool has_min_int() const;
  void clear_min_int();
  static const int kMinIntFieldNumber = 2;
  ::google::protobuf::int32 min_int() const;
  void set_min_int(::google::protobuf::int32 value);

  // optional int32 max_int = 3;
  bool has_max_int() const;
  void clear_max_int();
  static const int kMaxIntFieldNumber = 3;
  ::google::protobuf::int32 max_int() const;
  void set_max_int(::google::protobuf::int32 value);

  // repeated .aapt.pb.Attribute.Symbol symbol = 4;
  int symbol_size() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  const ::aapt::pb::Attribute_Symbol& symbol(int index) const;
  ::aapt::pb::Attribute_Symbol* mutable_symbol(int index);
  ::aapt::pb::Attribute_Symbol* add_symbol();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
      mutable_symbol();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
      symbol() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Attribute)
 private:
  inline void set_has_format_flags();
  inline void clear_has_format_flags();
  inline void set_has_min_int();
  inline void clear_has_min_int();
  inline void set_has_max_int();
  inline void clear_has_max_int();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 format_flags_;
  ::google::protobuf::int32 min_int_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol > symbol_;
  ::google::protobuf::int32 max_int_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Style_Entry : public ::google::protobuf::MessageLite {
 public:
  Style_Entry();
  virtual ~Style_Entry();

  Style_Entry(const Style_Entry& from);

  inline Style_Entry& operator=(const Style_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Style_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Style_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Style_Entry* other);

  // implements Message ----------------------------------------------

  inline Style_Entry* New() const { return New(NULL); }

  Style_Entry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Style_Entry& from);
  void MergeFrom(const Style_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Style_Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Reference key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::aapt::pb::Reference& key() const;
  ::aapt::pb::Reference* mutable_key();
  ::aapt::pb::Reference* release_key();
  void set_allocated_key(::aapt::pb::Reference* key);

  // optional .aapt.pb.Item item = 4;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 4;
  const ::aapt::pb::Item& item() const;
  ::aapt::pb::Item* mutable_item();
  ::aapt::pb::Item* release_item();
  void set_allocated_item(::aapt::pb::Item* item);

  // @@protoc_insertion_point(class_scope:aapt.pb.Style.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::aapt::pb::Reference* key_;
  ::aapt::pb::Item* item_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Style_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Style : public ::google::protobuf::MessageLite {
 public:
  Style();
  virtual ~Style();

  Style(const Style& from);

  inline Style& operator=(const Style& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Style& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Style* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Style* other);

  // implements Message ----------------------------------------------

  inline Style* New() const { return New(NULL); }

  Style* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Style& from);
  void MergeFrom(const Style& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Style* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Style_Entry Entry;

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Reference parent = 1;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 1;
  const ::aapt::pb::Reference& parent() const;
  ::aapt::pb::Reference* mutable_parent();
  ::aapt::pb::Reference* release_parent();
  void set_allocated_parent(::aapt::pb::Reference* parent);

  // optional .aapt.pb.Source parent_source = 2;
  bool has_parent_source() const;
  void clear_parent_source();
  static const int kParentSourceFieldNumber = 2;
  const ::aapt::pb::Source& parent_source() const;
  ::aapt::pb::Source* mutable_parent_source();
  ::aapt::pb::Source* release_parent_source();
  void set_allocated_parent_source(::aapt::pb::Source* parent_source);

  // repeated .aapt.pb.Style.Entry entry = 3;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 3;
  const ::aapt::pb::Style_Entry& entry(int index) const;
  ::aapt::pb::Style_Entry* mutable_entry(int index);
  ::aapt::pb::Style_Entry* add_entry();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >*
      mutable_entry();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Style)
 private:
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_parent_source();
  inline void clear_has_parent_source();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Reference* parent_;
  ::aapt::pb::Source* parent_source_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry > entry_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Style* default_instance_;
};
// -------------------------------------------------------------------

class Styleable_Entry : public ::google::protobuf::MessageLite {
 public:
  Styleable_Entry();
  virtual ~Styleable_Entry();

  Styleable_Entry(const Styleable_Entry& from);

  inline Styleable_Entry& operator=(const Styleable_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Styleable_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Styleable_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Styleable_Entry* other);

  // implements Message ----------------------------------------------

  inline Styleable_Entry* New() const { return New(NULL); }

  Styleable_Entry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Styleable_Entry& from);
  void MergeFrom(const Styleable_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Styleable_Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Reference attr = 3;
  bool has_attr() const;
  void clear_attr();
  static const int kAttrFieldNumber = 3;
  const ::aapt::pb::Reference& attr() const;
  ::aapt::pb::Reference* mutable_attr();
  ::aapt::pb::Reference* release_attr();
  void set_allocated_attr(::aapt::pb::Reference* attr);

  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_attr();
  inline void clear_has_attr();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::aapt::pb::Reference* attr_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Styleable_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Styleable : public ::google::protobuf::MessageLite {
 public:
  Styleable();
  virtual ~Styleable();

  Styleable(const Styleable& from);

  inline Styleable& operator=(const Styleable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Styleable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Styleable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Styleable* other);

  // implements Message ----------------------------------------------

  inline Styleable* New() const { return New(NULL); }

  Styleable* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Styleable& from);
  void MergeFrom(const Styleable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Styleable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Styleable_Entry Entry;

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.Styleable.Entry entry = 1;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 1;
  const ::aapt::pb::Styleable_Entry& entry(int index) const;
  ::aapt::pb::Styleable_Entry* mutable_entry(int index);
  ::aapt::pb::Styleable_Entry* add_entry();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
      mutable_entry();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Styleable)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry > entry_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Styleable* default_instance_;
};
// -------------------------------------------------------------------

class Array_Element : public ::google::protobuf::MessageLite {
 public:
  Array_Element();
  virtual ~Array_Element();

  Array_Element(const Array_Element& from);

  inline Array_Element& operator=(const Array_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Array_Element& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Array_Element* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Array_Element* other);

  // implements Message ----------------------------------------------

  inline Array_Element* New() const { return New(NULL); }

  Array_Element* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Array_Element& from);
  void MergeFrom(const Array_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Array_Element* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Item item = 3;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 3;
  const ::aapt::pb::Item& item() const;
  ::aapt::pb::Item* mutable_item();
  ::aapt::pb::Item* release_item();
  void set_allocated_item(::aapt::pb::Item* item);

  // @@protoc_insertion_point(class_scope:aapt.pb.Array.Element)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::aapt::pb::Item* item_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Array_Element* default_instance_;
};
// -------------------------------------------------------------------

class Array : public ::google::protobuf::MessageLite {
 public:
  Array();
  virtual ~Array();

  Array(const Array& from);

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Array& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Array* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Array* other);

  // implements Message ----------------------------------------------

  inline Array* New() const { return New(NULL); }

  Array* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Array* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Array_Element Element;

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.Array.Element element = 1;
  int element_size() const;
  void clear_element();
  static const int kElementFieldNumber = 1;
  const ::aapt::pb::Array_Element& element(int index) const;
  ::aapt::pb::Array_Element* mutable_element(int index);
  ::aapt::pb::Array_Element* add_element();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element >*
      mutable_element();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element >&
      element() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Array)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element > element_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Array* default_instance_;
};
// -------------------------------------------------------------------

class Plural_Entry : public ::google::protobuf::MessageLite {
 public:
  Plural_Entry();
  virtual ~Plural_Entry();

  Plural_Entry(const Plural_Entry& from);

  inline Plural_Entry& operator=(const Plural_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Plural_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Plural_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Plural_Entry* other);

  // implements Message ----------------------------------------------

  inline Plural_Entry* New() const { return New(NULL); }

  Plural_Entry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Plural_Entry& from);
  void MergeFrom(const Plural_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Plural_Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::aapt::pb::Source& source() const;
  ::aapt::pb::Source* mutable_source();
  ::aapt::pb::Source* release_source();
  void set_allocated_source(::aapt::pb::Source* source);

  // optional string comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional .aapt.pb.Plural.Arity arity = 3;
  bool has_arity() const;
  void clear_arity();
  static const int kArityFieldNumber = 3;
  ::aapt::pb::Plural_Arity arity() const;
  void set_arity(::aapt::pb::Plural_Arity value);

  // optional .aapt.pb.Item item = 4;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 4;
  const ::aapt::pb::Item& item() const;
  ::aapt::pb::Item* mutable_item();
  ::aapt::pb::Item* release_item();
  void set_allocated_item(::aapt::pb::Item* item);

  // @@protoc_insertion_point(class_scope:aapt.pb.Plural.Entry)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_arity();
  inline void clear_has_arity();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::Source* source_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::aapt::pb::Item* item_;
  int arity_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Plural_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Plural : public ::google::protobuf::MessageLite {
 public:
  Plural();
  virtual ~Plural();

  Plural(const Plural& from);

  inline Plural& operator=(const Plural& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Plural& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Plural* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Plural* other);

  // implements Message ----------------------------------------------

  inline Plural* New() const { return New(NULL); }

  Plural* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Plural& from);
  void MergeFrom(const Plural& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Plural* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Plural_Entry Entry;

  typedef Plural_Arity Arity;
  static const Arity ZERO =
    Plural_Arity_ZERO;
  static const Arity ONE =
    Plural_Arity_ONE;
  static const Arity TWO =
    Plural_Arity_TWO;
  static const Arity FEW =
    Plural_Arity_FEW;
  static const Arity MANY =
    Plural_Arity_MANY;
  static const Arity OTHER =
    Plural_Arity_OTHER;
  static inline bool Arity_IsValid(int value) {
    return Plural_Arity_IsValid(value);
  }
  static const Arity Arity_MIN =
    Plural_Arity_Arity_MIN;
  static const Arity Arity_MAX =
    Plural_Arity_Arity_MAX;
  static const int Arity_ARRAYSIZE =
    Plural_Arity_Arity_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.Plural.Entry entry = 1;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 1;
  const ::aapt::pb::Plural_Entry& entry(int index) const;
  ::aapt::pb::Plural_Entry* mutable_entry(int index);
  ::aapt::pb::Plural_Entry* add_entry();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
      mutable_entry();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.Plural)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry > entry_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static Plural* default_instance_;
};
// -------------------------------------------------------------------

class XmlNode : public ::google::protobuf::MessageLite {
 public:
  XmlNode();
  virtual ~XmlNode();

  XmlNode(const XmlNode& from);

  inline XmlNode& operator=(const XmlNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const XmlNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XmlNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XmlNode* other);

  // implements Message ----------------------------------------------

  inline XmlNode* New() const { return New(NULL); }

  XmlNode* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XmlNode& from);
  void MergeFrom(const XmlNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XmlNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aapt.pb.XmlElement element = 1;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 1;
  const ::aapt::pb::XmlElement& element() const;
  ::aapt::pb::XmlElement* mutable_element();
  ::aapt::pb::XmlElement* release_element();
  void set_allocated_element(::aapt::pb::XmlElement* element);

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .aapt.pb.SourcePosition source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::aapt::pb::SourcePosition& source() const;
  ::aapt::pb::SourcePosition* mutable_source();
  ::aapt::pb::SourcePosition* release_source();
  void set_allocated_source(::aapt::pb::SourcePosition* source);

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlNode)
 private:
  inline void set_has_element();
  inline void clear_has_element();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::aapt::pb::XmlElement* element_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::aapt::pb::SourcePosition* source_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static XmlNode* default_instance_;
};
// -------------------------------------------------------------------

class XmlElement : public ::google::protobuf::MessageLite {
 public:
  XmlElement();
  virtual ~XmlElement();

  XmlElement(const XmlElement& from);

  inline XmlElement& operator=(const XmlElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const XmlElement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XmlElement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XmlElement* other);

  // implements Message ----------------------------------------------

  inline XmlElement* New() const { return New(NULL); }

  XmlElement* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XmlElement& from);
  void MergeFrom(const XmlElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XmlElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
  int namespace_declaration_size() const;
  void clear_namespace_declaration();
  static const int kNamespaceDeclarationFieldNumber = 1;
  const ::aapt::pb::XmlNamespace& namespace_declaration(int index) const;
  ::aapt::pb::XmlNamespace* mutable_namespace_declaration(int index);
  ::aapt::pb::XmlNamespace* add_namespace_declaration();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
      mutable_namespace_declaration();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
      namespace_declaration() const;

  // optional string namespace_uri = 2;
  bool has_namespace_uri() const;
  void clear_namespace_uri();
  static const int kNamespaceUriFieldNumber = 2;
  const ::std::string& namespace_uri() const;
  void set_namespace_uri(const ::std::string& value);
  void set_namespace_uri(const char* value);
  void set_namespace_uri(const char* value, size_t size);
  ::std::string* mutable_namespace_uri();
  ::std::string* release_namespace_uri();
  void set_allocated_namespace_uri(::std::string* namespace_uri);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .aapt.pb.XmlAttribute attribute = 4;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 4;
  const ::aapt::pb::XmlAttribute& attribute(int index) const;
  ::aapt::pb::XmlAttribute* mutable_attribute(int index);
  ::aapt::pb::XmlAttribute* add_attribute();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
      mutable_attribute();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
      attribute() const;

  // repeated .aapt.pb.XmlNode child = 5;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  const ::aapt::pb::XmlNode& child(int index) const;
  ::aapt::pb::XmlNode* mutable_child(int index);
  ::aapt::pb::XmlNode* add_child();
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode >&
      child() const;

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlElement)
 private:
  inline void set_has_namespace_uri();
  inline void clear_has_namespace_uri();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace > namespace_declaration_;
  ::google::protobuf::internal::ArenaStringPtr namespace_uri_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute > attribute_;
  ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode > child_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static XmlElement* default_instance_;
};
// -------------------------------------------------------------------

class XmlNamespace : public ::google::protobuf::MessageLite {
 public:
  XmlNamespace();
  virtual ~XmlNamespace();

  XmlNamespace(const XmlNamespace& from);

  inline XmlNamespace& operator=(const XmlNamespace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const XmlNamespace& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XmlNamespace* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XmlNamespace* other);

  // implements Message ----------------------------------------------

  inline XmlNamespace* New() const { return New(NULL); }

  XmlNamespace* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XmlNamespace& from);
  void MergeFrom(const XmlNamespace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XmlNamespace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // optional string uri = 2;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 2;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // optional .aapt.pb.SourcePosition source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::aapt::pb::SourcePosition& source() const;
  ::aapt::pb::SourcePosition* mutable_source();
  ::aapt::pb::SourcePosition* release_source();
  void set_allocated_source(::aapt::pb::SourcePosition* source);

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlNamespace)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::aapt::pb::SourcePosition* source_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static XmlNamespace* default_instance_;
};
// -------------------------------------------------------------------

class XmlAttribute : public ::google::protobuf::MessageLite {
 public:
  XmlAttribute();
  virtual ~XmlAttribute();

  XmlAttribute(const XmlAttribute& from);

  inline XmlAttribute& operator=(const XmlAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const XmlAttribute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XmlAttribute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XmlAttribute* other);

  // implements Message ----------------------------------------------

  inline XmlAttribute* New() const { return New(NULL); }

  XmlAttribute* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XmlAttribute& from);
  void MergeFrom(const XmlAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XmlAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string namespace_uri = 1;
  bool has_namespace_uri() const;
  void clear_namespace_uri();
  static const int kNamespaceUriFieldNumber = 1;
  const ::std::string& namespace_uri() const;
  void set_namespace_uri(const ::std::string& value);
  void set_namespace_uri(const char* value);
  void set_namespace_uri(const char* value, size_t size);
  ::std::string* mutable_namespace_uri();
  ::std::string* release_namespace_uri();
  void set_allocated_namespace_uri(::std::string* namespace_uri);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .aapt.pb.SourcePosition source = 4;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  const ::aapt::pb::SourcePosition& source() const;
  ::aapt::pb::SourcePosition* mutable_source();
  ::aapt::pb::SourcePosition* release_source();
  void set_allocated_source(::aapt::pb::SourcePosition* source);

  // optional uint32 resource_id = 5;
  bool has_resource_id() const;
  void clear_resource_id();
  static const int kResourceIdFieldNumber = 5;
  ::google::protobuf::uint32 resource_id() const;
  void set_resource_id(::google::protobuf::uint32 value);

  // optional .aapt.pb.Item compiled_item = 6;
  bool has_compiled_item() const;
  void clear_compiled_item();
  static const int kCompiledItemFieldNumber = 6;
  const ::aapt::pb::Item& compiled_item() const;
  ::aapt::pb::Item* mutable_compiled_item();
  ::aapt::pb::Item* release_compiled_item();
  void set_allocated_compiled_item(::aapt::pb::Item* compiled_item);

  // @@protoc_insertion_point(class_scope:aapt.pb.XmlAttribute)
 private:
  inline void set_has_namespace_uri();
  inline void clear_has_namespace_uri();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();
  inline void set_has_compiled_item();
  inline void clear_has_compiled_item();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr namespace_uri_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::aapt::pb::SourcePosition* source_;
  ::aapt::pb::Item* compiled_item_;
  ::google::protobuf::uint32 resource_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  #endif
  friend void protobuf_AssignDesc_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();
  friend void protobuf_ShutdownFile_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto();

  void InitAsDefaultInstance();
  static XmlAttribute* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ConfigDescription

// optional bytes data = 1;
inline bool ConfigDescription::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigDescription::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigDescription::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigDescription::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ConfigDescription::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigDescription.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigDescription::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.ConfigDescription.data)
}
inline void ConfigDescription::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.ConfigDescription.data)
}
inline void ConfigDescription::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.ConfigDescription.data)
}
inline ::std::string* ConfigDescription::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigDescription.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigDescription::release_data() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigDescription.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigDescription::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigDescription.data)
}

// optional string product = 2;
inline bool ConfigDescription::has_product() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigDescription::set_has_product() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigDescription::clear_has_product() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigDescription::clear_product() {
  product_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_product();
}
inline const ::std::string& ConfigDescription::product() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigDescription.product)
  return product_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigDescription::set_product(const ::std::string& value) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.ConfigDescription.product)
}
inline void ConfigDescription::set_product(const char* value) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.ConfigDescription.product)
}
inline void ConfigDescription::set_product(const char* value, size_t size) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.ConfigDescription.product)
}
inline ::std::string* ConfigDescription::mutable_product() {
  set_has_product();
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigDescription.product)
  return product_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigDescription::release_product() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigDescription.product)
  clear_has_product();
  return product_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigDescription::set_allocated_product(::std::string* product) {
  if (product != NULL) {
    set_has_product();
  } else {
    clear_has_product();
  }
  product_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigDescription.product)
}

// -------------------------------------------------------------------

// StringPool

// optional bytes data = 1;
inline bool StringPool::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringPool::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringPool::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringPool::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& StringPool::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StringPool.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringPool::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.StringPool.data)
}
inline void StringPool::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.StringPool.data)
}
inline void StringPool::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StringPool.data)
}
inline ::std::string* StringPool::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StringPool.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringPool::release_data() {
  // @@protoc_insertion_point(field_release:aapt.pb.StringPool.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringPool::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StringPool.data)
}

// -------------------------------------------------------------------

// SourcePosition

// optional uint32 line_number = 1;
inline bool SourcePosition::has_line_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SourcePosition::set_has_line_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SourcePosition::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SourcePosition::clear_line_number() {
  line_number_ = 0u;
  clear_has_line_number();
}
inline ::google::protobuf::uint32 SourcePosition::line_number() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.line_number)
  return line_number_;
}
inline void SourcePosition::set_line_number(::google::protobuf::uint32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.line_number)
}

// optional uint32 column_number = 2;
inline bool SourcePosition::has_column_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SourcePosition::set_has_column_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SourcePosition::clear_has_column_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SourcePosition::clear_column_number() {
  column_number_ = 0u;
  clear_has_column_number();
}
inline ::google::protobuf::uint32 SourcePosition::column_number() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SourcePosition.column_number)
  return column_number_;
}
inline void SourcePosition::set_column_number(::google::protobuf::uint32 value) {
  set_has_column_number();
  column_number_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SourcePosition.column_number)
}

// -------------------------------------------------------------------

// Source

// optional uint32 path_idx = 1;
inline bool Source::has_path_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Source::set_has_path_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Source::clear_has_path_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Source::clear_path_idx() {
  path_idx_ = 0u;
  clear_has_path_idx();
}
inline ::google::protobuf::uint32 Source::path_idx() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.path_idx)
  return path_idx_;
}
inline void Source::set_path_idx(::google::protobuf::uint32 value) {
  set_has_path_idx();
  path_idx_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Source.path_idx)
}

// optional .aapt.pb.SourcePosition position = 2;
inline bool Source::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Source::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Source::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Source::clear_position() {
  if (position_ != NULL) position_->::aapt::pb::SourcePosition::Clear();
  clear_has_position();
}
inline const ::aapt::pb::SourcePosition& Source::position() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Source.position)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_ != NULL ? *position_ : *default_instance().position_;
#else
  return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
}
inline ::aapt::pb::SourcePosition* Source::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Source.position)
  return position_;
}
inline ::aapt::pb::SourcePosition* Source::release_position() {
  // @@protoc_insertion_point(field_release:aapt.pb.Source.position)
  clear_has_position();
  ::aapt::pb::SourcePosition* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Source::set_allocated_position(::aapt::pb::SourcePosition* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Source.position)
}

// -------------------------------------------------------------------

// ResourceTable

// optional .aapt.pb.StringPool source_pool = 1;
inline bool ResourceTable::has_source_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceTable::set_has_source_pool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceTable::clear_has_source_pool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceTable::clear_source_pool() {
  if (source_pool_ != NULL) source_pool_->::aapt::pb::StringPool::Clear();
  clear_has_source_pool();
}
inline const ::aapt::pb::StringPool& ResourceTable::source_pool() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.source_pool)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_pool_ != NULL ? *source_pool_ : *default_instance().source_pool_;
#else
  return source_pool_ != NULL ? *source_pool_ : *default_instance_->source_pool_;
#endif
}
inline ::aapt::pb::StringPool* ResourceTable::mutable_source_pool() {
  set_has_source_pool();
  if (source_pool_ == NULL) {
    source_pool_ = new ::aapt::pb::StringPool;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.source_pool)
  return source_pool_;
}
inline ::aapt::pb::StringPool* ResourceTable::release_source_pool() {
  // @@protoc_insertion_point(field_release:aapt.pb.ResourceTable.source_pool)
  clear_has_source_pool();
  ::aapt::pb::StringPool* temp = source_pool_;
  source_pool_ = NULL;
  return temp;
}
inline void ResourceTable::set_allocated_source_pool(::aapt::pb::StringPool* source_pool) {
  delete source_pool_;
  source_pool_ = source_pool;
  if (source_pool) {
    set_has_source_pool();
  } else {
    clear_has_source_pool();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ResourceTable.source_pool)
}

// repeated .aapt.pb.Package package = 2;
inline int ResourceTable::package_size() const {
  return package_.size();
}
inline void ResourceTable::clear_package() {
  package_.Clear();
}
inline const ::aapt::pb::Package& ResourceTable::package(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.ResourceTable.package)
  return package_.Get(index);
}
inline ::aapt::pb::Package* ResourceTable::mutable_package(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.ResourceTable.package)
  return package_.Mutable(index);
}
inline ::aapt::pb::Package* ResourceTable::add_package() {
  // @@protoc_insertion_point(field_add:aapt.pb.ResourceTable.package)
  return package_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >*
ResourceTable::mutable_package() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.ResourceTable.package)
  return &package_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Package >&
ResourceTable::package() const {
  // @@protoc_insertion_point(field_list:aapt.pb.ResourceTable.package)
  return package_;
}

// -------------------------------------------------------------------

// Package

// optional uint32 package_id = 1;
inline bool Package::has_package_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Package::set_has_package_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Package::clear_has_package_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Package::clear_package_id() {
  package_id_ = 0u;
  clear_has_package_id();
}
inline ::google::protobuf::uint32 Package::package_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_id)
  return package_id_;
}
inline void Package::set_package_id(::google::protobuf::uint32 value) {
  set_has_package_id();
  package_id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_id)
}

// optional string package_name = 2;
inline bool Package::has_package_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Package::set_has_package_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Package::clear_has_package_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Package::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_package_name();
}
inline const ::std::string& Package::package_name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.package_name)
  return package_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Package::set_package_name(const ::std::string& value) {
  set_has_package_name();
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Package.package_name)
}
inline void Package::set_package_name(const char* value) {
  set_has_package_name();
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Package.package_name)
}
inline void Package::set_package_name(const char* value, size_t size) {
  set_has_package_name();
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Package.package_name)
}
inline ::std::string* Package::mutable_package_name() {
  set_has_package_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.package_name)
  return package_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Package::release_package_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Package.package_name)
  clear_has_package_name();
  return package_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Package::set_allocated_package_name(::std::string* package_name) {
  if (package_name != NULL) {
    set_has_package_name();
  } else {
    clear_has_package_name();
  }
  package_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Package.package_name)
}

// repeated .aapt.pb.Type type = 3;
inline int Package::type_size() const {
  return type_.size();
}
inline void Package::clear_type() {
  type_.Clear();
}
inline const ::aapt::pb::Type& Package::type(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Package.type)
  return type_.Get(index);
}
inline ::aapt::pb::Type* Package::mutable_type(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Package.type)
  return type_.Mutable(index);
}
inline ::aapt::pb::Type* Package::add_type() {
  // @@protoc_insertion_point(field_add:aapt.pb.Package.type)
  return type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >*
Package::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Package.type)
  return &type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Type >&
Package::type() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Package.type)
  return type_;
}

// -------------------------------------------------------------------

// Type

// optional uint32 id = 1;
inline bool Type::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Type::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Type::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Type::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Type::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.id)
  return id_;
}
inline void Type::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Type.id)
}

// optional string name = 2;
inline bool Type::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Type::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Type::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Type::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Type.name)
}
inline void Type::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Type.name)
}
inline void Type::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Type.name)
}
inline ::std::string* Type::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Type.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Type.name)
}

// repeated .aapt.pb.Entry entry = 3;
inline int Type::entry_size() const {
  return entry_.size();
}
inline void Type::clear_entry() {
  entry_.Clear();
}
inline const ::aapt::pb::Entry& Type::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Type.entry)
  return entry_.Get(index);
}
inline ::aapt::pb::Entry* Type::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Type.entry)
  return entry_.Mutable(index);
}
inline ::aapt::pb::Entry* Type::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Type.entry)
  return entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >*
Type::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Type.entry)
  return &entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Entry >&
Type::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Type.entry)
  return entry_;
}

// -------------------------------------------------------------------

// SymbolStatus

// optional .aapt.pb.SymbolStatus.Visibility visibility = 1;
inline bool SymbolStatus::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatus::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatus::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatus::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::aapt::pb::SymbolStatus_Visibility SymbolStatus::visibility() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.visibility)
  return static_cast< ::aapt::pb::SymbolStatus_Visibility >(visibility_);
}
inline void SymbolStatus::set_visibility(::aapt::pb::SymbolStatus_Visibility value) {
  assert(::aapt::pb::SymbolStatus_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.visibility)
}

// optional .aapt.pb.Source source = 2;
inline bool SymbolStatus::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatus::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatus::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& SymbolStatus::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* SymbolStatus::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.SymbolStatus.source)
  return source_;
}
inline ::aapt::pb::Source* SymbolStatus::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.SymbolStatus.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void SymbolStatus::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.SymbolStatus.source)
}

// optional string comment = 3;
inline bool SymbolStatus::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatus::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatus::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatus::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& SymbolStatus::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolStatus::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.comment)
}
inline void SymbolStatus::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.SymbolStatus.comment)
}
inline void SymbolStatus::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.SymbolStatus.comment)
}
inline ::std::string* SymbolStatus::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.SymbolStatus.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolStatus::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.SymbolStatus.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolStatus::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.SymbolStatus.comment)
}

// optional bool allow_new = 4;
inline bool SymbolStatus::has_allow_new() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatus::set_has_allow_new() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatus::clear_has_allow_new() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatus::clear_allow_new() {
  allow_new_ = false;
  clear_has_allow_new();
}
inline bool SymbolStatus::allow_new() const {
  // @@protoc_insertion_point(field_get:aapt.pb.SymbolStatus.allow_new)
  return allow_new_;
}
inline void SymbolStatus::set_allow_new(bool value) {
  set_has_allow_new();
  allow_new_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.SymbolStatus.allow_new)
}

// -------------------------------------------------------------------

// Entry

// optional uint32 id = 1;
inline bool Entry::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entry::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entry::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entry::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Entry::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.id)
  return id_;
}
inline void Entry::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.id)
}

// optional string name = 2;
inline bool Entry::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entry::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entry::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Entry::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Entry.name)
}
inline void Entry::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Entry.name)
}
inline void Entry::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Entry.name)
}
inline ::std::string* Entry::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entry::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.name)
}

// optional .aapt.pb.SymbolStatus symbol_status = 3;
inline bool Entry::has_symbol_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entry::set_has_symbol_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entry::clear_has_symbol_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entry::clear_symbol_status() {
  if (symbol_status_ != NULL) symbol_status_->::aapt::pb::SymbolStatus::Clear();
  clear_has_symbol_status();
}
inline const ::aapt::pb::SymbolStatus& Entry::symbol_status() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.symbol_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return symbol_status_ != NULL ? *symbol_status_ : *default_instance().symbol_status_;
#else
  return symbol_status_ != NULL ? *symbol_status_ : *default_instance_->symbol_status_;
#endif
}
inline ::aapt::pb::SymbolStatus* Entry::mutable_symbol_status() {
  set_has_symbol_status();
  if (symbol_status_ == NULL) {
    symbol_status_ = new ::aapt::pb::SymbolStatus;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.symbol_status)
  return symbol_status_;
}
inline ::aapt::pb::SymbolStatus* Entry::release_symbol_status() {
  // @@protoc_insertion_point(field_release:aapt.pb.Entry.symbol_status)
  clear_has_symbol_status();
  ::aapt::pb::SymbolStatus* temp = symbol_status_;
  symbol_status_ = NULL;
  return temp;
}
inline void Entry::set_allocated_symbol_status(::aapt::pb::SymbolStatus* symbol_status) {
  delete symbol_status_;
  symbol_status_ = symbol_status;
  if (symbol_status) {
    set_has_symbol_status();
  } else {
    clear_has_symbol_status();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Entry.symbol_status)
}

// repeated .aapt.pb.ConfigValue config_value = 4;
inline int Entry::config_value_size() const {
  return config_value_.size();
}
inline void Entry::clear_config_value() {
  config_value_.Clear();
}
inline const ::aapt::pb::ConfigValue& Entry::config_value(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Entry.config_value)
  return config_value_.Get(index);
}
inline ::aapt::pb::ConfigValue* Entry::mutable_config_value(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Entry.config_value)
  return config_value_.Mutable(index);
}
inline ::aapt::pb::ConfigValue* Entry::add_config_value() {
  // @@protoc_insertion_point(field_add:aapt.pb.Entry.config_value)
  return config_value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >*
Entry::mutable_config_value() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Entry.config_value)
  return &config_value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::ConfigValue >&
Entry::config_value() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Entry.config_value)
  return config_value_;
}

// -------------------------------------------------------------------

// ConfigValue

// optional .aapt.pb.ConfigDescription config = 1;
inline bool ConfigValue::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigValue::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigValue::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigValue::clear_config() {
  if (config_ != NULL) config_->::aapt::pb::ConfigDescription::Clear();
  clear_has_config();
}
inline const ::aapt::pb::ConfigDescription& ConfigValue::config() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::aapt::pb::ConfigDescription* ConfigValue::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::aapt::pb::ConfigDescription;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.config)
  return config_;
}
inline ::aapt::pb::ConfigDescription* ConfigValue::release_config() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.config)
  clear_has_config();
  ::aapt::pb::ConfigDescription* temp = config_;
  config_ = NULL;
  return temp;
}
inline void ConfigValue::set_allocated_config(::aapt::pb::ConfigDescription* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.config)
}

// optional .aapt.pb.Value value = 2;
inline bool ConfigValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigValue::clear_value() {
  if (value_ != NULL) value_->::aapt::pb::Value::Clear();
  clear_has_value();
}
inline const ::aapt::pb::Value& ConfigValue::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.ConfigValue.value)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return value_ != NULL ? *value_ : *default_instance().value_;
#else
  return value_ != NULL ? *value_ : *default_instance_->value_;
#endif
}
inline ::aapt::pb::Value* ConfigValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::aapt::pb::Value;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.ConfigValue.value)
  return value_;
}
inline ::aapt::pb::Value* ConfigValue::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.ConfigValue.value)
  clear_has_value();
  ::aapt::pb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ConfigValue::set_allocated_value(::aapt::pb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.ConfigValue.value)
}

// -------------------------------------------------------------------

// Value

// optional .aapt.pb.Source source = 1;
inline bool Value::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Value::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Value::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.source)
  return source_;
}
inline ::aapt::pb::Source* Value::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Value::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.source)
}

// optional string comment = 2;
inline bool Value::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Value::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Value.comment)
}
inline void Value::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Value.comment)
}
inline void Value::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Value.comment)
}
inline ::std::string* Value::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.comment)
}

// optional bool weak = 3;
inline bool Value::has_weak() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_weak() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_weak() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_weak() {
  weak_ = false;
  clear_has_weak();
}
inline bool Value::weak() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.weak)
  return weak_;
}
inline void Value::set_weak(bool value) {
  set_has_weak();
  weak_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Value.weak)
}

// optional .aapt.pb.Item item = 4;
inline bool Value::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Value::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Value::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.item)
  return item_;
}
inline ::aapt::pb::Item* Value::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Value::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.item)
}

// optional .aapt.pb.CompoundValue compound_value = 5;
inline bool Value::has_compound_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_compound_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_compound_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_compound_value() {
  if (compound_value_ != NULL) compound_value_->::aapt::pb::CompoundValue::Clear();
  clear_has_compound_value();
}
inline const ::aapt::pb::CompoundValue& Value::compound_value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Value.compound_value)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compound_value_ != NULL ? *compound_value_ : *default_instance().compound_value_;
#else
  return compound_value_ != NULL ? *compound_value_ : *default_instance_->compound_value_;
#endif
}
inline ::aapt::pb::CompoundValue* Value::mutable_compound_value() {
  set_has_compound_value();
  if (compound_value_ == NULL) {
    compound_value_ = new ::aapt::pb::CompoundValue;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Value.compound_value)
  return compound_value_;
}
inline ::aapt::pb::CompoundValue* Value::release_compound_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.Value.compound_value)
  clear_has_compound_value();
  ::aapt::pb::CompoundValue* temp = compound_value_;
  compound_value_ = NULL;
  return temp;
}
inline void Value::set_allocated_compound_value(::aapt::pb::CompoundValue* compound_value) {
  delete compound_value_;
  compound_value_ = compound_value;
  if (compound_value) {
    set_has_compound_value();
  } else {
    clear_has_compound_value();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Value.compound_value)
}

// -------------------------------------------------------------------

// Item

// optional .aapt.pb.Reference ref = 1;
inline bool Item::has_ref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_ref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_ref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_ref() {
  if (ref_ != NULL) ref_->::aapt::pb::Reference::Clear();
  clear_has_ref();
}
inline const ::aapt::pb::Reference& Item::ref() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.ref)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ref_ != NULL ? *ref_ : *default_instance().ref_;
#else
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
#endif
}
inline ::aapt::pb::Reference* Item::mutable_ref() {
  set_has_ref();
  if (ref_ == NULL) {
    ref_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.ref)
  return ref_;
}
inline ::aapt::pb::Reference* Item::release_ref() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.ref)
  clear_has_ref();
  ::aapt::pb::Reference* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void Item::set_allocated_ref(::aapt::pb::Reference* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    set_has_ref();
  } else {
    clear_has_ref();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.ref)
}

// optional .aapt.pb.String str = 2;
inline bool Item::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_str() {
  if (str_ != NULL) str_->::aapt::pb::String::Clear();
  clear_has_str();
}
inline const ::aapt::pb::String& Item::str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return str_ != NULL ? *str_ : *default_instance().str_;
#else
  return str_ != NULL ? *str_ : *default_instance_->str_;
#endif
}
inline ::aapt::pb::String* Item::mutable_str() {
  set_has_str();
  if (str_ == NULL) {
    str_ = new ::aapt::pb::String;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.str)
  return str_;
}
inline ::aapt::pb::String* Item::release_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.str)
  clear_has_str();
  ::aapt::pb::String* temp = str_;
  str_ = NULL;
  return temp;
}
inline void Item::set_allocated_str(::aapt::pb::String* str) {
  delete str_;
  str_ = str;
  if (str) {
    set_has_str();
  } else {
    clear_has_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.str)
}

// optional .aapt.pb.RawString raw_str = 3;
inline bool Item::has_raw_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_raw_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_raw_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_raw_str() {
  if (raw_str_ != NULL) raw_str_->::aapt::pb::RawString::Clear();
  clear_has_raw_str();
}
inline const ::aapt::pb::RawString& Item::raw_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.raw_str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return raw_str_ != NULL ? *raw_str_ : *default_instance().raw_str_;
#else
  return raw_str_ != NULL ? *raw_str_ : *default_instance_->raw_str_;
#endif
}
inline ::aapt::pb::RawString* Item::mutable_raw_str() {
  set_has_raw_str();
  if (raw_str_ == NULL) {
    raw_str_ = new ::aapt::pb::RawString;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.raw_str)
  return raw_str_;
}
inline ::aapt::pb::RawString* Item::release_raw_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.raw_str)
  clear_has_raw_str();
  ::aapt::pb::RawString* temp = raw_str_;
  raw_str_ = NULL;
  return temp;
}
inline void Item::set_allocated_raw_str(::aapt::pb::RawString* raw_str) {
  delete raw_str_;
  raw_str_ = raw_str;
  if (raw_str) {
    set_has_raw_str();
  } else {
    clear_has_raw_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.raw_str)
}

// optional .aapt.pb.StyledString styled_str = 4;
inline bool Item::has_styled_str() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item::set_has_styled_str() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item::clear_has_styled_str() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item::clear_styled_str() {
  if (styled_str_ != NULL) styled_str_->::aapt::pb::StyledString::Clear();
  clear_has_styled_str();
}
inline const ::aapt::pb::StyledString& Item::styled_str() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.styled_str)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return styled_str_ != NULL ? *styled_str_ : *default_instance().styled_str_;
#else
  return styled_str_ != NULL ? *styled_str_ : *default_instance_->styled_str_;
#endif
}
inline ::aapt::pb::StyledString* Item::mutable_styled_str() {
  set_has_styled_str();
  if (styled_str_ == NULL) {
    styled_str_ = new ::aapt::pb::StyledString;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.styled_str)
  return styled_str_;
}
inline ::aapt::pb::StyledString* Item::release_styled_str() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.styled_str)
  clear_has_styled_str();
  ::aapt::pb::StyledString* temp = styled_str_;
  styled_str_ = NULL;
  return temp;
}
inline void Item::set_allocated_styled_str(::aapt::pb::StyledString* styled_str) {
  delete styled_str_;
  styled_str_ = styled_str;
  if (styled_str) {
    set_has_styled_str();
  } else {
    clear_has_styled_str();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.styled_str)
}

// optional .aapt.pb.FileReference file = 5;
inline bool Item::has_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item::set_has_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item::clear_has_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item::clear_file() {
  if (file_ != NULL) file_->::aapt::pb::FileReference::Clear();
  clear_has_file();
}
inline const ::aapt::pb::FileReference& Item::file() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.file)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return file_ != NULL ? *file_ : *default_instance().file_;
#else
  return file_ != NULL ? *file_ : *default_instance_->file_;
#endif
}
inline ::aapt::pb::FileReference* Item::mutable_file() {
  set_has_file();
  if (file_ == NULL) {
    file_ = new ::aapt::pb::FileReference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.file)
  return file_;
}
inline ::aapt::pb::FileReference* Item::release_file() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.file)
  clear_has_file();
  ::aapt::pb::FileReference* temp = file_;
  file_ = NULL;
  return temp;
}
inline void Item::set_allocated_file(::aapt::pb::FileReference* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.file)
}

// optional .aapt.pb.Id id = 6;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item::clear_id() {
  if (id_ != NULL) id_->::aapt::pb::Id::Clear();
  clear_has_id();
}
inline const ::aapt::pb::Id& Item::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aapt::pb::Id* Item::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::aapt::pb::Id;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.id)
  return id_;
}
inline ::aapt::pb::Id* Item::release_id() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.id)
  clear_has_id();
  ::aapt::pb::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Item::set_allocated_id(::aapt::pb::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.id)
}

// optional .aapt.pb.Primitive prim = 7;
inline bool Item::has_prim() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Item::set_has_prim() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Item::clear_has_prim() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Item::clear_prim() {
  if (prim_ != NULL) prim_->::aapt::pb::Primitive::Clear();
  clear_has_prim();
}
inline const ::aapt::pb::Primitive& Item::prim() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Item.prim)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return prim_ != NULL ? *prim_ : *default_instance().prim_;
#else
  return prim_ != NULL ? *prim_ : *default_instance_->prim_;
#endif
}
inline ::aapt::pb::Primitive* Item::mutable_prim() {
  set_has_prim();
  if (prim_ == NULL) {
    prim_ = new ::aapt::pb::Primitive;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Item.prim)
  return prim_;
}
inline ::aapt::pb::Primitive* Item::release_prim() {
  // @@protoc_insertion_point(field_release:aapt.pb.Item.prim)
  clear_has_prim();
  ::aapt::pb::Primitive* temp = prim_;
  prim_ = NULL;
  return temp;
}
inline void Item::set_allocated_prim(::aapt::pb::Primitive* prim) {
  delete prim_;
  prim_ = prim;
  if (prim) {
    set_has_prim();
  } else {
    clear_has_prim();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Item.prim)
}

// -------------------------------------------------------------------

// CompoundValue

// optional .aapt.pb.Attribute attr = 1;
inline bool CompoundValue::has_attr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompoundValue::set_has_attr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompoundValue::clear_has_attr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompoundValue::clear_attr() {
  if (attr_ != NULL) attr_->::aapt::pb::Attribute::Clear();
  clear_has_attr();
}
inline const ::aapt::pb::Attribute& CompoundValue::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.attr)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_ != NULL ? *attr_ : *default_instance().attr_;
#else
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
#endif
}
inline ::aapt::pb::Attribute* CompoundValue::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) {
    attr_ = new ::aapt::pb::Attribute;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.attr)
  return attr_;
}
inline ::aapt::pb::Attribute* CompoundValue::release_attr() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.attr)
  clear_has_attr();
  ::aapt::pb::Attribute* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_attr(::aapt::pb::Attribute* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.attr)
}

// optional .aapt.pb.Style style = 2;
inline bool CompoundValue::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompoundValue::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompoundValue::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompoundValue::clear_style() {
  if (style_ != NULL) style_->::aapt::pb::Style::Clear();
  clear_has_style();
}
inline const ::aapt::pb::Style& CompoundValue::style() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.style)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return style_ != NULL ? *style_ : *default_instance().style_;
#else
  return style_ != NULL ? *style_ : *default_instance_->style_;
#endif
}
inline ::aapt::pb::Style* CompoundValue::mutable_style() {
  set_has_style();
  if (style_ == NULL) {
    style_ = new ::aapt::pb::Style;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.style)
  return style_;
}
inline ::aapt::pb::Style* CompoundValue::release_style() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.style)
  clear_has_style();
  ::aapt::pb::Style* temp = style_;
  style_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_style(::aapt::pb::Style* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.style)
}

// optional .aapt.pb.Styleable styleable = 3;
inline bool CompoundValue::has_styleable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompoundValue::set_has_styleable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompoundValue::clear_has_styleable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompoundValue::clear_styleable() {
  if (styleable_ != NULL) styleable_->::aapt::pb::Styleable::Clear();
  clear_has_styleable();
}
inline const ::aapt::pb::Styleable& CompoundValue::styleable() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.styleable)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return styleable_ != NULL ? *styleable_ : *default_instance().styleable_;
#else
  return styleable_ != NULL ? *styleable_ : *default_instance_->styleable_;
#endif
}
inline ::aapt::pb::Styleable* CompoundValue::mutable_styleable() {
  set_has_styleable();
  if (styleable_ == NULL) {
    styleable_ = new ::aapt::pb::Styleable;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.styleable)
  return styleable_;
}
inline ::aapt::pb::Styleable* CompoundValue::release_styleable() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.styleable)
  clear_has_styleable();
  ::aapt::pb::Styleable* temp = styleable_;
  styleable_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_styleable(::aapt::pb::Styleable* styleable) {
  delete styleable_;
  styleable_ = styleable;
  if (styleable) {
    set_has_styleable();
  } else {
    clear_has_styleable();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.styleable)
}

// optional .aapt.pb.Array array = 4;
inline bool CompoundValue::has_array() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompoundValue::set_has_array() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CompoundValue::clear_has_array() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CompoundValue::clear_array() {
  if (array_ != NULL) array_->::aapt::pb::Array::Clear();
  clear_has_array();
}
inline const ::aapt::pb::Array& CompoundValue::array() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.array)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return array_ != NULL ? *array_ : *default_instance().array_;
#else
  return array_ != NULL ? *array_ : *default_instance_->array_;
#endif
}
inline ::aapt::pb::Array* CompoundValue::mutable_array() {
  set_has_array();
  if (array_ == NULL) {
    array_ = new ::aapt::pb::Array;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.array)
  return array_;
}
inline ::aapt::pb::Array* CompoundValue::release_array() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.array)
  clear_has_array();
  ::aapt::pb::Array* temp = array_;
  array_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_array(::aapt::pb::Array* array) {
  delete array_;
  array_ = array;
  if (array) {
    set_has_array();
  } else {
    clear_has_array();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.array)
}

// optional .aapt.pb.Plural plural = 5;
inline bool CompoundValue::has_plural() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CompoundValue::set_has_plural() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CompoundValue::clear_has_plural() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CompoundValue::clear_plural() {
  if (plural_ != NULL) plural_->::aapt::pb::Plural::Clear();
  clear_has_plural();
}
inline const ::aapt::pb::Plural& CompoundValue::plural() const {
  // @@protoc_insertion_point(field_get:aapt.pb.CompoundValue.plural)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return plural_ != NULL ? *plural_ : *default_instance().plural_;
#else
  return plural_ != NULL ? *plural_ : *default_instance_->plural_;
#endif
}
inline ::aapt::pb::Plural* CompoundValue::mutable_plural() {
  set_has_plural();
  if (plural_ == NULL) {
    plural_ = new ::aapt::pb::Plural;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.CompoundValue.plural)
  return plural_;
}
inline ::aapt::pb::Plural* CompoundValue::release_plural() {
  // @@protoc_insertion_point(field_release:aapt.pb.CompoundValue.plural)
  clear_has_plural();
  ::aapt::pb::Plural* temp = plural_;
  plural_ = NULL;
  return temp;
}
inline void CompoundValue::set_allocated_plural(::aapt::pb::Plural* plural) {
  delete plural_;
  plural_ = plural;
  if (plural) {
    set_has_plural();
  } else {
    clear_has_plural();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.CompoundValue.plural)
}

// -------------------------------------------------------------------

// Reference

// optional .aapt.pb.Reference.Type type = 1;
inline bool Reference::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reference::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reference::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reference::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::aapt::pb::Reference_Type Reference::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.type)
  return static_cast< ::aapt::pb::Reference_Type >(type_);
}
inline void Reference::set_type(::aapt::pb::Reference_Type value) {
  assert(::aapt::pb::Reference_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.type)
}

// optional uint32 id = 2;
inline bool Reference::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reference::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reference::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reference::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Reference::id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.id)
  return id_;
}
inline void Reference::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.id)
}

// optional string name = 3;
inline bool Reference::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reference::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reference::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reference::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Reference::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reference::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.name)
}
inline void Reference::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Reference.name)
}
inline void Reference::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Reference.name)
}
inline ::std::string* Reference::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Reference.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reference::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Reference.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reference::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Reference.name)
}

// optional bool private = 4;
inline bool Reference::has_private_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reference::set_has_private_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reference::clear_has_private_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reference::clear_private_() {
  private__ = false;
  clear_has_private_();
}
inline bool Reference::private_() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Reference.private)
  return private__;
}
inline void Reference::set_private_(bool value) {
  set_has_private_();
  private__ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Reference.private)
}

// -------------------------------------------------------------------

// Id

// -------------------------------------------------------------------

// String

// optional string value = 1;
inline bool String::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void String::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void String::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void String::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& String::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.String.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.String.value)
}
inline void String::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.String.value)
}
inline void String::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.String.value)
}
inline ::std::string* String::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.String.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* String::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.String.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.String.value)
}

// -------------------------------------------------------------------

// RawString

// optional string value = 1;
inline bool RawString::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawString::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawString::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawString::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& RawString::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.RawString.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawString::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.RawString.value)
}
inline void RawString::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.RawString.value)
}
inline void RawString::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.RawString.value)
}
inline ::std::string* RawString::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.RawString.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawString::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.RawString.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawString::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.RawString.value)
}

// -------------------------------------------------------------------

// StyledString_Span

// optional string tag = 1;
inline bool StyledString_Span::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyledString_Span::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyledString_Span::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyledString_Span::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tag();
}
inline const ::std::string& StyledString_Span::tag() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.tag)
  return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StyledString_Span::set_tag(const ::std::string& value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.tag)
}
inline void StyledString_Span::set_tag(const char* value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.StyledString.Span.tag)
}
inline void StyledString_Span::set_tag(const char* value, size_t size) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StyledString.Span.tag)
}
inline ::std::string* StyledString_Span::mutable_tag() {
  set_has_tag();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.Span.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StyledString_Span::release_tag() {
  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.Span.tag)
  clear_has_tag();
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StyledString_Span::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.Span.tag)
}

// optional uint32 first_char = 2;
inline bool StyledString_Span::has_first_char() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyledString_Span::set_has_first_char() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyledString_Span::clear_has_first_char() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyledString_Span::clear_first_char() {
  first_char_ = 0u;
  clear_has_first_char();
}
inline ::google::protobuf::uint32 StyledString_Span::first_char() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.first_char)
  return first_char_;
}
inline void StyledString_Span::set_first_char(::google::protobuf::uint32 value) {
  set_has_first_char();
  first_char_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.first_char)
}

// optional uint32 last_char = 3;
inline bool StyledString_Span::has_last_char() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyledString_Span::set_has_last_char() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyledString_Span::clear_has_last_char() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyledString_Span::clear_last_char() {
  last_char_ = 0u;
  clear_has_last_char();
}
inline ::google::protobuf::uint32 StyledString_Span::last_char() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.Span.last_char)
  return last_char_;
}
inline void StyledString_Span::set_last_char(::google::protobuf::uint32 value) {
  set_has_last_char();
  last_char_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.Span.last_char)
}

// -------------------------------------------------------------------

// StyledString

// optional string value = 1;
inline bool StyledString::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyledString::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyledString::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyledString::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& StyledString::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StyledString::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.StyledString.value)
}
inline void StyledString::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.StyledString.value)
}
inline void StyledString::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.StyledString.value)
}
inline ::std::string* StyledString::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StyledString::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.StyledString.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StyledString::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.StyledString.value)
}

// repeated .aapt.pb.StyledString.Span span = 2;
inline int StyledString::span_size() const {
  return span_.size();
}
inline void StyledString::clear_span() {
  span_.Clear();
}
inline const ::aapt::pb::StyledString_Span& StyledString::span(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.StyledString.span)
  return span_.Get(index);
}
inline ::aapt::pb::StyledString_Span* StyledString::mutable_span(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.StyledString.span)
  return span_.Mutable(index);
}
inline ::aapt::pb::StyledString_Span* StyledString::add_span() {
  // @@protoc_insertion_point(field_add:aapt.pb.StyledString.span)
  return span_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span >*
StyledString::mutable_span() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.StyledString.span)
  return &span_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::StyledString_Span >&
StyledString::span() const {
  // @@protoc_insertion_point(field_list:aapt.pb.StyledString.span)
  return span_;
}

// -------------------------------------------------------------------

// FileReference

// optional string path = 1;
inline bool FileReference::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileReference::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileReference::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileReference::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& FileReference::path() const {
  // @@protoc_insertion_point(field_get:aapt.pb.FileReference.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileReference::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.FileReference.path)
}
inline void FileReference::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.FileReference.path)
}
inline void FileReference::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.FileReference.path)
}
inline ::std::string* FileReference::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:aapt.pb.FileReference.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileReference::release_path() {
  // @@protoc_insertion_point(field_release:aapt.pb.FileReference.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileReference::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.FileReference.path)
}

// -------------------------------------------------------------------

// Primitive

// optional uint32 type = 1;
inline bool Primitive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Primitive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Primitive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Primitive::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Primitive::type() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.type)
  return type_;
}
inline void Primitive::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.type)
}

// optional uint32 data = 2;
inline bool Primitive::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Primitive::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Primitive::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Primitive::clear_data() {
  data_ = 0u;
  clear_has_data();
}
inline ::google::protobuf::uint32 Primitive::data() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Primitive.data)
  return data_;
}
inline void Primitive::set_data(::google::protobuf::uint32 value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Primitive.data)
}

// -------------------------------------------------------------------

// Attribute_Symbol

// optional .aapt.pb.Source source = 1;
inline bool Attribute_Symbol::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute_Symbol::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute_Symbol::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute_Symbol::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Attribute_Symbol::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Attribute_Symbol::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.source)
  return source_;
}
inline ::aapt::pb::Source* Attribute_Symbol::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Attribute_Symbol::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.source)
}

// optional string comment = 2;
inline bool Attribute_Symbol::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute_Symbol::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute_Symbol::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute_Symbol::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Attribute_Symbol::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute_Symbol::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.comment)
}
inline void Attribute_Symbol::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Attribute.Symbol.comment)
}
inline void Attribute_Symbol::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Attribute.Symbol.comment)
}
inline ::std::string* Attribute_Symbol::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Attribute_Symbol::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute_Symbol::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.comment)
}

// optional .aapt.pb.Reference name = 3;
inline bool Attribute_Symbol::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute_Symbol::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute_Symbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute_Symbol::clear_name() {
  if (name_ != NULL) name_->::aapt::pb::Reference::Clear();
  clear_has_name();
}
inline const ::aapt::pb::Reference& Attribute_Symbol::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.name)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return name_ != NULL ? *name_ : *default_instance().name_;
#else
  return name_ != NULL ? *name_ : *default_instance_->name_;
#endif
}
inline ::aapt::pb::Reference* Attribute_Symbol::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    name_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.Symbol.name)
  return name_;
}
inline ::aapt::pb::Reference* Attribute_Symbol::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.Attribute.Symbol.name)
  clear_has_name();
  ::aapt::pb::Reference* temp = name_;
  name_ = NULL;
  return temp;
}
inline void Attribute_Symbol::set_allocated_name(::aapt::pb::Reference* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Attribute.Symbol.name)
}

// optional uint32 value = 4;
inline bool Attribute_Symbol::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute_Symbol::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute_Symbol::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute_Symbol::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 Attribute_Symbol::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.Symbol.value)
  return value_;
}
inline void Attribute_Symbol::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.Symbol.value)
}

// -------------------------------------------------------------------

// Attribute

// optional uint32 format_flags = 1;
inline bool Attribute::has_format_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_format_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_format_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_format_flags() {
  format_flags_ = 0u;
  clear_has_format_flags();
}
inline ::google::protobuf::uint32 Attribute::format_flags() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.format_flags)
  return format_flags_;
}
inline void Attribute::set_format_flags(::google::protobuf::uint32 value) {
  set_has_format_flags();
  format_flags_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.format_flags)
}

// optional int32 min_int = 2;
inline bool Attribute::has_min_int() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_min_int() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_min_int() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_min_int() {
  min_int_ = 0;
  clear_has_min_int();
}
inline ::google::protobuf::int32 Attribute::min_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.min_int)
  return min_int_;
}
inline void Attribute::set_min_int(::google::protobuf::int32 value) {
  set_has_min_int();
  min_int_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.min_int)
}

// optional int32 max_int = 3;
inline bool Attribute::has_max_int() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_max_int() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_max_int() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_max_int() {
  max_int_ = 0;
  clear_has_max_int();
}
inline ::google::protobuf::int32 Attribute::max_int() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.max_int)
  return max_int_;
}
inline void Attribute::set_max_int(::google::protobuf::int32 value) {
  set_has_max_int();
  max_int_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Attribute.max_int)
}

// repeated .aapt.pb.Attribute.Symbol symbol = 4;
inline int Attribute::symbol_size() const {
  return symbol_.size();
}
inline void Attribute::clear_symbol() {
  symbol_.Clear();
}
inline const ::aapt::pb::Attribute_Symbol& Attribute::symbol(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Attribute.symbol)
  return symbol_.Get(index);
}
inline ::aapt::pb::Attribute_Symbol* Attribute::mutable_symbol(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Attribute.symbol)
  return symbol_.Mutable(index);
}
inline ::aapt::pb::Attribute_Symbol* Attribute::add_symbol() {
  // @@protoc_insertion_point(field_add:aapt.pb.Attribute.symbol)
  return symbol_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >*
Attribute::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Attribute.symbol)
  return &symbol_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Attribute_Symbol >&
Attribute::symbol() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Attribute.symbol)
  return symbol_;
}

// -------------------------------------------------------------------

// Style_Entry

// optional .aapt.pb.Source source = 1;
inline bool Style_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Style_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Style_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Style_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Style_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Style_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Style_Entry::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Style_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.source)
}

// optional string comment = 2;
inline bool Style_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Style_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Style_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Style_Entry::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Style_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Style_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Style.Entry.comment)
}
inline void Style_Entry::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Style.Entry.comment)
}
inline void Style_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Style.Entry.comment)
}
inline ::std::string* Style_Entry::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Style_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Style_Entry::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.comment)
}

// optional .aapt.pb.Reference key = 3;
inline bool Style_Entry::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Style_Entry::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Style_Entry::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Style_Entry::clear_key() {
  if (key_ != NULL) key_->::aapt::pb::Reference::Clear();
  clear_has_key();
}
inline const ::aapt::pb::Reference& Style_Entry::key() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return key_ != NULL ? *key_ : *default_instance().key_;
#else
  return key_ != NULL ? *key_ : *default_instance_->key_;
#endif
}
inline ::aapt::pb::Reference* Style_Entry::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.key)
  return key_;
}
inline ::aapt::pb::Reference* Style_Entry::release_key() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.key)
  clear_has_key();
  ::aapt::pb::Reference* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Style_Entry::set_allocated_key(::aapt::pb::Reference* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.key)
}

// optional .aapt.pb.Item item = 4;
inline bool Style_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Style_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Style_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Style_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Style_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Style_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.Entry.item)
  return item_;
}
inline ::aapt::pb::Item* Style_Entry::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.Entry.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Style_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.Entry.item)
}

// -------------------------------------------------------------------

// Style

// optional .aapt.pb.Reference parent = 1;
inline bool Style::has_parent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Style::set_has_parent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Style::clear_has_parent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Style::clear_parent() {
  if (parent_ != NULL) parent_->::aapt::pb::Reference::Clear();
  clear_has_parent();
}
inline const ::aapt::pb::Reference& Style::parent() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parent_ != NULL ? *parent_ : *default_instance().parent_;
#else
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
#endif
}
inline ::aapt::pb::Reference* Style::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) {
    parent_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent)
  return parent_;
}
inline ::aapt::pb::Reference* Style::release_parent() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent)
  clear_has_parent();
  ::aapt::pb::Reference* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void Style::set_allocated_parent(::aapt::pb::Reference* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent)
}

// optional .aapt.pb.Source parent_source = 2;
inline bool Style::has_parent_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Style::set_has_parent_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Style::clear_has_parent_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Style::clear_parent_source() {
  if (parent_source_ != NULL) parent_source_->::aapt::pb::Source::Clear();
  clear_has_parent_source();
}
inline const ::aapt::pb::Source& Style::parent_source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.parent_source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parent_source_ != NULL ? *parent_source_ : *default_instance().parent_source_;
#else
  return parent_source_ != NULL ? *parent_source_ : *default_instance_->parent_source_;
#endif
}
inline ::aapt::pb::Source* Style::mutable_parent_source() {
  set_has_parent_source();
  if (parent_source_ == NULL) {
    parent_source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.parent_source)
  return parent_source_;
}
inline ::aapt::pb::Source* Style::release_parent_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Style.parent_source)
  clear_has_parent_source();
  ::aapt::pb::Source* temp = parent_source_;
  parent_source_ = NULL;
  return temp;
}
inline void Style::set_allocated_parent_source(::aapt::pb::Source* parent_source) {
  delete parent_source_;
  parent_source_ = parent_source;
  if (parent_source) {
    set_has_parent_source();
  } else {
    clear_has_parent_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Style.parent_source)
}

// repeated .aapt.pb.Style.Entry entry = 3;
inline int Style::entry_size() const {
  return entry_.size();
}
inline void Style::clear_entry() {
  entry_.Clear();
}
inline const ::aapt::pb::Style_Entry& Style::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Style.entry)
  return entry_.Get(index);
}
inline ::aapt::pb::Style_Entry* Style::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Style.entry)
  return entry_.Mutable(index);
}
inline ::aapt::pb::Style_Entry* Style::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Style.entry)
  return entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >*
Style::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Style.entry)
  return &entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Style_Entry >&
Style::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Style.entry)
  return entry_;
}

// -------------------------------------------------------------------

// Styleable_Entry

// optional .aapt.pb.Source source = 1;
inline bool Styleable_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Styleable_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Styleable_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Styleable_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Styleable_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Styleable_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Styleable_Entry::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Styleable_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.source)
}

// optional string comment = 2;
inline bool Styleable_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Styleable_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Styleable_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Styleable_Entry::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Styleable_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Styleable_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Styleable.Entry.comment)
}
inline void Styleable_Entry::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Styleable.Entry.comment)
}
inline void Styleable_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Styleable.Entry.comment)
}
inline ::std::string* Styleable_Entry::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Styleable_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Styleable_Entry::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.comment)
}

// optional .aapt.pb.Reference attr = 3;
inline bool Styleable_Entry::has_attr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Styleable_Entry::set_has_attr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Styleable_Entry::clear_has_attr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Styleable_Entry::clear_attr() {
  if (attr_ != NULL) attr_->::aapt::pb::Reference::Clear();
  clear_has_attr();
}
inline const ::aapt::pb::Reference& Styleable_Entry::attr() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.Entry.attr)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_ != NULL ? *attr_ : *default_instance().attr_;
#else
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
#endif
}
inline ::aapt::pb::Reference* Styleable_Entry::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) {
    attr_ = new ::aapt::pb::Reference;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.Entry.attr)
  return attr_;
}
inline ::aapt::pb::Reference* Styleable_Entry::release_attr() {
  // @@protoc_insertion_point(field_release:aapt.pb.Styleable.Entry.attr)
  clear_has_attr();
  ::aapt::pb::Reference* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void Styleable_Entry::set_allocated_attr(::aapt::pb::Reference* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Styleable.Entry.attr)
}

// -------------------------------------------------------------------

// Styleable

// repeated .aapt.pb.Styleable.Entry entry = 1;
inline int Styleable::entry_size() const {
  return entry_.size();
}
inline void Styleable::clear_entry() {
  entry_.Clear();
}
inline const ::aapt::pb::Styleable_Entry& Styleable::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Styleable.entry)
  return entry_.Get(index);
}
inline ::aapt::pb::Styleable_Entry* Styleable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Styleable.entry)
  return entry_.Mutable(index);
}
inline ::aapt::pb::Styleable_Entry* Styleable::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Styleable.entry)
  return entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >*
Styleable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Styleable.entry)
  return &entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Styleable_Entry >&
Styleable::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Styleable.entry)
  return entry_;
}

// -------------------------------------------------------------------

// Array_Element

// optional .aapt.pb.Source source = 1;
inline bool Array_Element::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Array_Element::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Array_Element::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Array_Element::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Array_Element::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Array_Element::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.source)
  return source_;
}
inline ::aapt::pb::Source* Array_Element::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Array_Element::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.source)
}

// optional string comment = 2;
inline bool Array_Element::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Array_Element::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Array_Element::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Array_Element::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Array_Element::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Array_Element::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Array.Element.comment)
}
inline void Array_Element::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Array.Element.comment)
}
inline void Array_Element::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Array.Element.comment)
}
inline ::std::string* Array_Element::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Array_Element::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Array_Element::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.comment)
}

// optional .aapt.pb.Item item = 3;
inline bool Array_Element::has_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Array_Element::set_has_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Array_Element::clear_has_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Array_Element::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Array_Element::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.Element.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Array_Element::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.Element.item)
  return item_;
}
inline ::aapt::pb::Item* Array_Element::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Array.Element.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Array_Element::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Array.Element.item)
}

// -------------------------------------------------------------------

// Array

// repeated .aapt.pb.Array.Element element = 1;
inline int Array::element_size() const {
  return element_.size();
}
inline void Array::clear_element() {
  element_.Clear();
}
inline const ::aapt::pb::Array_Element& Array::element(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Array.element)
  return element_.Get(index);
}
inline ::aapt::pb::Array_Element* Array::mutable_element(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Array.element)
  return element_.Mutable(index);
}
inline ::aapt::pb::Array_Element* Array::add_element() {
  // @@protoc_insertion_point(field_add:aapt.pb.Array.element)
  return element_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element >*
Array::mutable_element() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Array.element)
  return &element_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Array_Element >&
Array::element() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Array.element)
  return element_;
}

// -------------------------------------------------------------------

// Plural_Entry

// optional .aapt.pb.Source source = 1;
inline bool Plural_Entry::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plural_Entry::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plural_Entry::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plural_Entry::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::Source::Clear();
  clear_has_source();
}
inline const ::aapt::pb::Source& Plural_Entry::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::Source* Plural_Entry::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::Source;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.source)
  return source_;
}
inline ::aapt::pb::Source* Plural_Entry::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.source)
  clear_has_source();
  ::aapt::pb::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Plural_Entry::set_allocated_source(::aapt::pb::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.source)
}

// optional string comment = 2;
inline bool Plural_Entry::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plural_Entry::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plural_Entry::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plural_Entry::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Plural_Entry::comment() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Plural_Entry::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.comment)
}
inline void Plural_Entry::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.Plural.Entry.comment)
}
inline void Plural_Entry::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.Plural.Entry.comment)
}
inline ::std::string* Plural_Entry::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Plural_Entry::release_comment() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Plural_Entry::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.comment)
}

// optional .aapt.pb.Plural.Arity arity = 3;
inline bool Plural_Entry::has_arity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plural_Entry::set_has_arity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plural_Entry::clear_has_arity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plural_Entry::clear_arity() {
  arity_ = 0;
  clear_has_arity();
}
inline ::aapt::pb::Plural_Arity Plural_Entry::arity() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.arity)
  return static_cast< ::aapt::pb::Plural_Arity >(arity_);
}
inline void Plural_Entry::set_arity(::aapt::pb::Plural_Arity value) {
  assert(::aapt::pb::Plural_Arity_IsValid(value));
  set_has_arity();
  arity_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.Plural.Entry.arity)
}

// optional .aapt.pb.Item item = 4;
inline bool Plural_Entry::has_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plural_Entry::set_has_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Plural_Entry::clear_has_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Plural_Entry::clear_item() {
  if (item_ != NULL) item_->::aapt::pb::Item::Clear();
  clear_has_item();
}
inline const ::aapt::pb::Item& Plural_Entry::item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.Entry.item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::aapt::pb::Item* Plural_Entry::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.Entry.item)
  return item_;
}
inline ::aapt::pb::Item* Plural_Entry::release_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.Plural.Entry.item)
  clear_has_item();
  ::aapt::pb::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Plural_Entry::set_allocated_item(::aapt::pb::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.Plural.Entry.item)
}

// -------------------------------------------------------------------

// Plural

// repeated .aapt.pb.Plural.Entry entry = 1;
inline int Plural::entry_size() const {
  return entry_.size();
}
inline void Plural::clear_entry() {
  entry_.Clear();
}
inline const ::aapt::pb::Plural_Entry& Plural::entry(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.Plural.entry)
  return entry_.Get(index);
}
inline ::aapt::pb::Plural_Entry* Plural::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.Plural.entry)
  return entry_.Mutable(index);
}
inline ::aapt::pb::Plural_Entry* Plural::add_entry() {
  // @@protoc_insertion_point(field_add:aapt.pb.Plural.entry)
  return entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >*
Plural::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.Plural.entry)
  return &entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::Plural_Entry >&
Plural::entry() const {
  // @@protoc_insertion_point(field_list:aapt.pb.Plural.entry)
  return entry_;
}

// -------------------------------------------------------------------

// XmlNode

// optional .aapt.pb.XmlElement element = 1;
inline bool XmlNode::has_element() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmlNode::set_has_element() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmlNode::clear_has_element() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmlNode::clear_element() {
  if (element_ != NULL) element_->::aapt::pb::XmlElement::Clear();
  clear_has_element();
}
inline const ::aapt::pb::XmlElement& XmlNode::element() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.element)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return element_ != NULL ? *element_ : *default_instance().element_;
#else
  return element_ != NULL ? *element_ : *default_instance_->element_;
#endif
}
inline ::aapt::pb::XmlElement* XmlNode::mutable_element() {
  set_has_element();
  if (element_ == NULL) {
    element_ = new ::aapt::pb::XmlElement;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.element)
  return element_;
}
inline ::aapt::pb::XmlElement* XmlNode::release_element() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.element)
  clear_has_element();
  ::aapt::pb::XmlElement* temp = element_;
  element_ = NULL;
  return temp;
}
inline void XmlNode::set_allocated_element(::aapt::pb::XmlElement* element) {
  delete element_;
  element_ = element;
  if (element) {
    set_has_element();
  } else {
    clear_has_element();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.element)
}

// optional string text = 2;
inline bool XmlNode::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlNode::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlNode::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlNode::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& XmlNode::text() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlNode::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNode.text)
}
inline void XmlNode::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlNode.text)
}
inline void XmlNode::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlNode.text)
}
inline ::std::string* XmlNode::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlNode::release_text() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlNode::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.text)
}

// optional .aapt.pb.SourcePosition source = 3;
inline bool XmlNode::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XmlNode::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XmlNode::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XmlNode::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
  clear_has_source();
}
inline const ::aapt::pb::SourcePosition& XmlNode::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNode.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::SourcePosition* XmlNode::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNode.source)
  return source_;
}
inline ::aapt::pb::SourcePosition* XmlNode::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNode.source)
  clear_has_source();
  ::aapt::pb::SourcePosition* temp = source_;
  source_ = NULL;
  return temp;
}
inline void XmlNode::set_allocated_source(::aapt::pb::SourcePosition* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNode.source)
}

// -------------------------------------------------------------------

// XmlElement

// repeated .aapt.pb.XmlNamespace namespace_declaration = 1;
inline int XmlElement::namespace_declaration_size() const {
  return namespace_declaration_.size();
}
inline void XmlElement::clear_namespace_declaration() {
  namespace_declaration_.Clear();
}
inline const ::aapt::pb::XmlNamespace& XmlElement::namespace_declaration(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_.Get(index);
}
inline ::aapt::pb::XmlNamespace* XmlElement::mutable_namespace_declaration(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_.Mutable(index);
}
inline ::aapt::pb::XmlNamespace* XmlElement::add_namespace_declaration() {
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace >*
XmlElement::mutable_namespace_declaration() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.namespace_declaration)
  return &namespace_declaration_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNamespace >&
XmlElement::namespace_declaration() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.namespace_declaration)
  return namespace_declaration_;
}

// optional string namespace_uri = 2;
inline bool XmlElement::has_namespace_uri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlElement::set_has_namespace_uri() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlElement::clear_has_namespace_uri() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlElement::clear_namespace_uri() {
  namespace_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_uri();
}
inline const ::std::string& XmlElement::namespace_uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.namespace_uri)
  return namespace_uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlElement::set_namespace_uri(const ::std::string& value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.namespace_uri)
}
inline void XmlElement::set_namespace_uri(const char* value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlElement.namespace_uri)
}
inline void XmlElement::set_namespace_uri(const char* value, size_t size) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlElement.namespace_uri)
}
inline ::std::string* XmlElement::mutable_namespace_uri() {
  set_has_namespace_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.namespace_uri)
  return namespace_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlElement::release_namespace_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.namespace_uri)
  clear_has_namespace_uri();
  return namespace_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlElement::set_allocated_namespace_uri(::std::string* namespace_uri) {
  if (namespace_uri != NULL) {
    set_has_namespace_uri();
  } else {
    clear_has_namespace_uri();
  }
  namespace_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_uri);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.namespace_uri)
}

// optional string name = 3;
inline bool XmlElement::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XmlElement::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XmlElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XmlElement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& XmlElement::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlElement::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlElement.name)
}
inline void XmlElement::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlElement.name)
}
inline void XmlElement::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlElement.name)
}
inline ::std::string* XmlElement::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlElement::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlElement.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlElement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlElement.name)
}

// repeated .aapt.pb.XmlAttribute attribute = 4;
inline int XmlElement::attribute_size() const {
  return attribute_.size();
}
inline void XmlElement::clear_attribute() {
  attribute_.Clear();
}
inline const ::aapt::pb::XmlAttribute& XmlElement::attribute(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.attribute)
  return attribute_.Get(index);
}
inline ::aapt::pb::XmlAttribute* XmlElement::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.attribute)
  return attribute_.Mutable(index);
}
inline ::aapt::pb::XmlAttribute* XmlElement::add_attribute() {
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.attribute)
  return attribute_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute >*
XmlElement::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.attribute)
  return &attribute_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlAttribute >&
XmlElement::attribute() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.attribute)
  return attribute_;
}

// repeated .aapt.pb.XmlNode child = 5;
inline int XmlElement::child_size() const {
  return child_.size();
}
inline void XmlElement::clear_child() {
  child_.Clear();
}
inline const ::aapt::pb::XmlNode& XmlElement::child(int index) const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlElement.child)
  return child_.Get(index);
}
inline ::aapt::pb::XmlNode* XmlElement::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlElement.child)
  return child_.Mutable(index);
}
inline ::aapt::pb::XmlNode* XmlElement::add_child() {
  // @@protoc_insertion_point(field_add:aapt.pb.XmlElement.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode >*
XmlElement::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:aapt.pb.XmlElement.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aapt::pb::XmlNode >&
XmlElement::child() const {
  // @@protoc_insertion_point(field_list:aapt.pb.XmlElement.child)
  return child_;
}

// -------------------------------------------------------------------

// XmlNamespace

// optional string prefix = 1;
inline bool XmlNamespace::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmlNamespace::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmlNamespace::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmlNamespace::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix();
}
inline const ::std::string& XmlNamespace::prefix() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.prefix)
  return prefix_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlNamespace::set_prefix(const ::std::string& value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.prefix)
}
inline void XmlNamespace::set_prefix(const char* value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlNamespace.prefix)
}
inline void XmlNamespace::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlNamespace.prefix)
}
inline ::std::string* XmlNamespace::mutable_prefix() {
  set_has_prefix();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlNamespace::release_prefix() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.prefix)
  clear_has_prefix();
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlNamespace::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.prefix)
}

// optional string uri = 2;
inline bool XmlNamespace::has_uri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlNamespace::set_has_uri() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlNamespace::clear_has_uri() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlNamespace::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
inline const ::std::string& XmlNamespace::uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.uri)
  return uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlNamespace::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlNamespace.uri)
}
inline void XmlNamespace::set_uri(const char* value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlNamespace.uri)
}
inline void XmlNamespace::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlNamespace.uri)
}
inline ::std::string* XmlNamespace::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlNamespace::release_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.uri)
  clear_has_uri();
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlNamespace::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.uri)
}

// optional .aapt.pb.SourcePosition source = 3;
inline bool XmlNamespace::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XmlNamespace::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XmlNamespace::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XmlNamespace::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
  clear_has_source();
}
inline const ::aapt::pb::SourcePosition& XmlNamespace::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlNamespace.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::SourcePosition* XmlNamespace::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlNamespace.source)
  return source_;
}
inline ::aapt::pb::SourcePosition* XmlNamespace::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlNamespace.source)
  clear_has_source();
  ::aapt::pb::SourcePosition* temp = source_;
  source_ = NULL;
  return temp;
}
inline void XmlNamespace::set_allocated_source(::aapt::pb::SourcePosition* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlNamespace.source)
}

// -------------------------------------------------------------------

// XmlAttribute

// optional string namespace_uri = 1;
inline bool XmlAttribute::has_namespace_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmlAttribute::set_has_namespace_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmlAttribute::clear_has_namespace_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmlAttribute::clear_namespace_uri() {
  namespace_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_uri();
}
inline const ::std::string& XmlAttribute::namespace_uri() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.namespace_uri)
  return namespace_uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlAttribute::set_namespace_uri(const ::std::string& value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.namespace_uri)
}
inline void XmlAttribute::set_namespace_uri(const char* value) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlAttribute.namespace_uri)
}
inline void XmlAttribute::set_namespace_uri(const char* value, size_t size) {
  set_has_namespace_uri();
  namespace_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlAttribute.namespace_uri)
}
inline ::std::string* XmlAttribute::mutable_namespace_uri() {
  set_has_namespace_uri();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.namespace_uri)
  return namespace_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlAttribute::release_namespace_uri() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.namespace_uri)
  clear_has_namespace_uri();
  return namespace_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlAttribute::set_allocated_namespace_uri(::std::string* namespace_uri) {
  if (namespace_uri != NULL) {
    set_has_namespace_uri();
  } else {
    clear_has_namespace_uri();
  }
  namespace_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_uri);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.namespace_uri)
}

// optional string name = 2;
inline bool XmlAttribute::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlAttribute::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlAttribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlAttribute::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& XmlAttribute::name() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlAttribute::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.name)
}
inline void XmlAttribute::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlAttribute.name)
}
inline void XmlAttribute::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlAttribute.name)
}
inline ::std::string* XmlAttribute::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlAttribute::release_name() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlAttribute::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.name)
}

// optional string value = 3;
inline bool XmlAttribute::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XmlAttribute::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XmlAttribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XmlAttribute::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& XmlAttribute::value() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlAttribute::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.value)
}
inline void XmlAttribute::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aapt.pb.XmlAttribute.value)
}
inline void XmlAttribute::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aapt.pb.XmlAttribute.value)
}
inline ::std::string* XmlAttribute::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XmlAttribute::release_value() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XmlAttribute::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.value)
}

// optional .aapt.pb.SourcePosition source = 4;
inline bool XmlAttribute::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XmlAttribute::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XmlAttribute::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XmlAttribute::clear_source() {
  if (source_ != NULL) source_->::aapt::pb::SourcePosition::Clear();
  clear_has_source();
}
inline const ::aapt::pb::SourcePosition& XmlAttribute::source() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.source)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_ != NULL ? *source_ : *default_instance().source_;
#else
  return source_ != NULL ? *source_ : *default_instance_->source_;
#endif
}
inline ::aapt::pb::SourcePosition* XmlAttribute::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::aapt::pb::SourcePosition;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.source)
  return source_;
}
inline ::aapt::pb::SourcePosition* XmlAttribute::release_source() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.source)
  clear_has_source();
  ::aapt::pb::SourcePosition* temp = source_;
  source_ = NULL;
  return temp;
}
inline void XmlAttribute::set_allocated_source(::aapt::pb::SourcePosition* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.source)
}

// optional uint32 resource_id = 5;
inline bool XmlAttribute::has_resource_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XmlAttribute::set_has_resource_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XmlAttribute::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XmlAttribute::clear_resource_id() {
  resource_id_ = 0u;
  clear_has_resource_id();
}
inline ::google::protobuf::uint32 XmlAttribute::resource_id() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.resource_id)
  return resource_id_;
}
inline void XmlAttribute::set_resource_id(::google::protobuf::uint32 value) {
  set_has_resource_id();
  resource_id_ = value;
  // @@protoc_insertion_point(field_set:aapt.pb.XmlAttribute.resource_id)
}

// optional .aapt.pb.Item compiled_item = 6;
inline bool XmlAttribute::has_compiled_item() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XmlAttribute::set_has_compiled_item() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XmlAttribute::clear_has_compiled_item() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XmlAttribute::clear_compiled_item() {
  if (compiled_item_ != NULL) compiled_item_->::aapt::pb::Item::Clear();
  clear_has_compiled_item();
}
inline const ::aapt::pb::Item& XmlAttribute::compiled_item() const {
  // @@protoc_insertion_point(field_get:aapt.pb.XmlAttribute.compiled_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compiled_item_ != NULL ? *compiled_item_ : *default_instance().compiled_item_;
#else
  return compiled_item_ != NULL ? *compiled_item_ : *default_instance_->compiled_item_;
#endif
}
inline ::aapt::pb::Item* XmlAttribute::mutable_compiled_item() {
  set_has_compiled_item();
  if (compiled_item_ == NULL) {
    compiled_item_ = new ::aapt::pb::Item;
  }
  // @@protoc_insertion_point(field_mutable:aapt.pb.XmlAttribute.compiled_item)
  return compiled_item_;
}
inline ::aapt::pb::Item* XmlAttribute::release_compiled_item() {
  // @@protoc_insertion_point(field_release:aapt.pb.XmlAttribute.compiled_item)
  clear_has_compiled_item();
  ::aapt::pb::Item* temp = compiled_item_;
  compiled_item_ = NULL;
  return temp;
}
inline void XmlAttribute::set_allocated_compiled_item(::aapt::pb::Item* compiled_item) {
  delete compiled_item_;
  compiled_item_ = compiled_item;
  if (compiled_item) {
    set_has_compiled_item();
  } else {
    clear_has_compiled_item();
  }
  // @@protoc_insertion_point(field_set_allocated:aapt.pb.XmlAttribute.compiled_item)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace aapt

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aapt::pb::SymbolStatus_Visibility> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aapt::pb::Reference_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aapt::pb::Attribute_FormatFlags> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aapt::pb::Plural_Arity> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_frameworks_2fbase_2ftools_2faapt2_2fResources_2eproto__INCLUDED
